---
createdAt: 2025-08-02T18:52:14.7276394
modifiedAt: 2025-08-02T18:52:38.8153351
---
- 크기가 N×N인 격자에서 연습하려고 한다. N은 항상 홀수이고, (r, c)는 격자의 r행 c열을 의미한다. 격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이며 마법사 상어는 ((N+1)/2, (N+1)/2)에 있다. 
- 일부 칸과 칸 사이에는 벽이 세워져 있으며, 실선은 벽이고, 점선은 벽이 아니다. 칸에 적혀있는 수는 칸의 번호이다.
- 가장 처음에 상어가 있는 칸을 제외한 나머지 칸에는 구슬이 하나 들어갈 수 있다. 구슬은 1번 구슬, 2번 구슬, 3번 구슬이 있다. 같은 번호를 가진 구슬이 번호가 연속하는 칸에 있으면, 그 구슬을 연속하는 구슬이라고 한다.
- 블리자드 마법을 시전하려면 방향 di와 거리 si를 정해야 한다. 총 4가지 방향 ↑, ↓, ←, →가 있고, 정수 1, 2, 3, 4로 나타낸다. 상어는 di 방향으로 거리가 si 이하인 모든 칸에 얼음 파편을 던져 그 칸에 있는 구슬을 모두 파괴한다. 구슬이 파괴되면 그 칸은 구슬이 들어있지 않은 빈 칸이 된다. 얼음 파편은 벽의 위로 떨어지기 때문에, 벽은 파괴되지 않는다.
- 만약 어떤 칸 A의 번호보다 번호가 하나 작은 칸이 빈 칸이면, A에 있는 구슬은 그 빈 칸으로 이동한다. 이 이동은 더 이상 구슬이 이동하지 않을 때까지 반복된다. 따라서, 구슬이 파괴된 후에는 빈 칸이 생겨 구슬이 이동한다.
- 이제 구슬이 폭발하는 단계이다. 폭발하는 구슬은 4개 이상 연속하는 구슬이 있을 때 발생한다.
- 구슬이 폭발해 빈 칸이 생겼으니 다시 구슬이 이동한다. 구슬이 이동한 후에는 다시 구슬이 폭발하는 단계이고, 이 과정은 더 이상 폭발하는 구슬이 없을때까지 반복된다.
- 이제 더 이상 폭발한 구슬이 없기 때문에, 구슬이 변화하는 단계가 된다. 연속하는 구슬은 하나의 그룹이라고 한다.
- 하나의 그룹은 두 개의 구슬 A와 B로 변한다. 구슬 A의 번호는 그룹에 들어있는 구슬의 개수이고, B는 그룹을 이루고 있는 구슬의 번호이다. 구슬은 다시 그룹의 순서대로 1번 칸부터 차례대로 A, B의 순서로 칸에 들어간다. 만약, 구슬이 칸의 수보다 많아 칸에 들어가지 못하는 경우 그러한 구슬은 사라진다.
- 마법사 상어는 블리자드를 총 M번 시전했다. 시전한 마법의 정보가 주어졌을 때, 1×(폭발한 1번 구슬의 개수) + 2×(폭발한 2번 구슬의 개수) + 3×(폭발한 3번 구슬의 개수)를 구해보자.
- 입력:
	- 3 ≤ N ≤ 49 ( N은 홀수 )
	- 1 ≤ M ≤ 100
	- 1 ≤ di ≤ 4,  1 ≤ si ≤ (N-1)/2
	- - 입력으로 주어진 격자에는 4개 이상 연속하는 구슬이 없다.
- 생각 흐름
	- 나선의 형태로 이동이 핵심 
	- 블리자드 -> 구슬 이동 -> ( 폭발 -> 이동 ) -> 복사가 반복된다. 
		- 이동 부분을 공통으로 빼면 좋을 듯 
		- 복사 부분은 기존의 구슬을 큐에 넣어 놓고 범위 넘어가지 않는 선에서 복사 
- 주의
	

``` c++
#include <iostream>
#include <vector>
#include <queue>
#include <deque>
#include <algorithm>
#include <utility>
using namespace std;

int n, m;
int glassCnt[4] = {0,0,0,0};
// 0 상 하 좌 우 (idx: 1~4)
int dy[5] = {0, -1, 1, 0, 0};
int dx[5] = {0, 0, 0, -1, 1};

void boom(vector<int> &glass, vector<vector<int>> &arr);
void move(vector<vector<int>> &arr);

int changeDir(int dir){
	if(dir == 1){
		return 3;
	}else if(dir == 2){
		return 4;
	}else if(dir == 3){
		return 2;
	}else{
		return 1;
	}
}

// 블리자드 
void doBlizard(vector<vector<int>> &arr, int dir, int range){
	int sharkY = (n+1)/2;
	int sharkX = sharkY;
	for(int i=0; i < range; i++){
		int ny = sharkY + dy[dir];
		int nx = sharkX + dx[dir];
		if(ny >= 1 && ny <=n && nx>=1 && nx <= n){
			// 파괴한 구슬 cnt
			glassCnt[arr[ny][nx]]++; 
			arr[ny][nx] = 0;
		}
		sharkY = ny;
		sharkX = nx;
	}

	// 블리자드 후 이동
	move(arr);
}
// 빈곳 구슬 이동 (나선형);
void move(vector<vector<int>> &arr){
	int startY = (n+1)/2;
	int startX = startY;
	// len: 1 1 2 2 3 3 4 4 5 5
	// dir: 좌,하,우, 상 
	int len = 1;
	int dir = 3; // 시작 방향: 좌
	vector<int> glass; // 안깨진 구슬들 삽입 
	while(!(startY == 0 && startX == 0)){
		for(int i=0; i<2; i++){
			for(int j=0; j<len; j++){
				int ny = startY + dy[dir];
				int nx = startX + dx[dir];
				if(ny >= 1 && ny <=n && nx>=1 && nx <= n && arr[ny][nx] != 0){
					glass.push_back(arr[ny][nx]);
				}
				dir = changeDir(dir);
				startY = ny;
				startX = nx;
			}
		}
		len++;
	}

	// 폭발 -> 이동 반복 후 복사 이루어짐 
	boom(glass, arr);
	return;
}
// 안깨진 구슬들을 이용해서 연속으로 4개이상 연속하면 폭파 -> + 복사
void boom(vector<int> &glass, vector<vector<int>> &arr){
	if(glass.size() == 0) return;
	queue<int> q;
	deque<int> s;
	for(int i=0; i<glass.size(); i++){
		q.push(glass[i]);
	}

	bool flag = false;


	while(flag != true || !q.empty()){
		flag = true;
		int len = 1;
		int now = q.front();
		s.push_back(now);
		q.pop();
		while(!q.empty()){
			int next = q.front();
			q.pop();
			if(now == next){
				len++;
			}else{
				if(len >= 4){
					// 폭파 갱신
					flag = false;
					glassCnt[now] += len;
				}
				int cnt = 0;
				while(cnt < len){ // 폭파 구슬 제거 
					s.pop_back();
					cnt++;
				}
				len = 1;
				now = next;
			}
			s.push_back(next);
		}
		// 이 작업 이후 s에 남은 s를 이용해서 다시 폭발 처리
		while(!s.empty()){
			int tmp = s.front();
			s.pop_front();
			q.push(tmp);
		}
	}

	// 연속된 폭발 종료 후의 복사가 이루어진다 
	queue<int> newQ;
	// 만약 q에 남은 갯수가 1개 이하라면 
	if(q.size() <= 1){
		if(q.size() == 1){
			newQ.push(1);
			newQ.push(q.top());
			q.pop();
		}
	}else{
		int now;
		int len = 0;
		while(!q.empty){
			now = q.front();
			q.pop();
			len++;
		}
		
		while(!q.empty()){
			int next = q.front();
			q.pop();
			if(now != next){
				newQ.push(len);
				if(newQ.size() >= (n*n-1)){
					break;
				}
				newQ.push(now);
				if(newQ.size() >= (n*n-1)){
					break;
				}
				now = next;
				len = 1;

			}else{
				len++;
			}
			
		}
	}

	// arr 갱신
	int startY = (n+1)/2;
	int startX = startY;
	// len: 1 1 2 2 3 3 4 4 5 5
	// dir: 좌,하,우, 상 
	int len = 1;
	int dir = 3; // 시작 방향: 좌
	vector<vector<int>> newArr(n+1,vector<int>(n+1));
	while(!newQ.empty()){
		for(int i=0; i<2; i++){
			for(int j=0; j<len; j++){
				int ny = startY + dy[dir];
				int nx = startX + dx[dir];
				if(ny >= 1 && ny <=n && nx>=1 && nx <= n){
					newArr[ny][nx] = newQ.top();
					newQ.pop();
				}
				dir = changeDir(dir);
				startY = ny;
				startX = nx;
			}
		}
		len++;
	}

	// arr 갱신
	arr = newArr;
	return;
}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	cin >> n >> m;
	vector<vector<int>> arr(n+1, vector<int>(n+1));

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <=n; j++){
			cin >> arr[i][j];
		}
	}

	
	for(int i=0; i<m; i++){
		int dir, range;
		cin >> dir >> range;
		doBlizard(arr, dir, range);
	}

	int res = 0;
	for(int i=1; i<=3; i++){
		res += (glassCnt[i]*i);
	}
	cout << res;
	
	return 0;
}

```
