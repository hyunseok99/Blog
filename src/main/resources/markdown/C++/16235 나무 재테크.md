---
createdAt: 2025-08-02T18:52:14.1609965
modifiedAt: 2025-08-02T18:52:14.1609965
---
- 부동산 투자로 억대의 돈을 번 상도는 최근 N×N 크기의 땅을 구매했다. 상도는 손쉬운 땅 관리를 위해 땅을 1×1 크기의 칸으로 나누어 놓았다. 각각의 칸은 (r, c)로 나타내며, r은 가장 위에서부터 떨어진 칸의 개수, c는 가장 왼쪽으로부터 떨어진 칸의 개수이다. r과 c는 1부터 시작한다.
- 땅의 양분을 조사하는 로봇 S2D2를 만들었다. S2D2는 1×1 크기의 칸에 들어있는 양분을 조사해 상도에게 전송하고, 모든 칸에 대해서 조사를 한다. 가장 처음에 양분은 모든 칸에 5만큼 들어있다.
- 나무 재테크란 작은 묘목을 구매해 어느정도 키운 후 팔아서 수익을 얻는 재테크이다. 상도는 나무 재테크로 더 큰 돈을 벌기 위해 M개의 나무를 구매해 땅에 심었다. 같은 1×1 크기의 칸에 여러 개의 나무가 심어져 있을 수도 있다.
- 이 나무는 사계절을 보내며, 아래와 같은 과정을 반복한다.
- 봄에는 나무가 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다. 각각의 나무는 나무가 있는 1×1 크기의 칸에 있는 양분만 먹을 수 있다. 하나의 칸에 여러 개의 나무가 있다면, 나이가 어린 나무부터 양분을 먹는다. 만약, 땅에 양분이 부족해 자신의 나이만큼 양분을 먹을 수 없는 나무는 양분을 먹지 못하고 즉시 죽는다.
- 여름에는 봄에 죽은 나무가 양분으로 변하게 된다. 각각의 죽은 나무마다 나이를 2로 나눈 값이 나무가 있던 칸에 양분으로 추가된다. 소수점 아래는 버린다.
- 가을에는 나무가 번식한다. 번식하는 나무는 나이가 5의 배수이어야 하며, 인접한 8개의 칸에 나이가 1인 나무가 생긴다. 어떤 칸 (r, c)와 인접한 칸은 (r-1, c-1), (r-1, c), (r-1, c+1), (r, c-1), (r, c+1), (r+1, c-1), (r+1, c), (r+1, c+1) 이다. 상도의 땅을 벗어나는 칸에는 나무가 생기지 않는다
- 겨울에는 S2D2가 땅을 돌아다니면서 땅에 양분을 추가한다. 각 칸에 추가되는 양분의 양은 A[r][c]이고, 입력으로 주어진다.
- K년이 지난 후 상도의 땅에 살아있는 나무의 개수를 구하는 프로그램을 작성

- 생각 흐름
	- 우선순위 큐를 이용해서 나무의 나이가 최소인 애들을 알아야 함  => min-heap 이용 
	-  문제는 나무의 나이가 최소인 경우의 x,y 좌표도 알아야 함
	- 
	
	

``` c++
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int n, m, k;

// 8방향
int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1};
int dy[8] = {0, 0, -1, 1, 1, -1, -1, 1};

// arr 땅의 양분, tree 나무 , arrA 겨울에 추가할 양분
void yearFunc(vector<vector<int>> &arr, vector<vector<priority_queue<int,vector<int>, greater<int>>>> &tree,
vector<vector<int>> &arrA){
	for(int i=1; i<=n; i++){
		for(int j=1; j<=n; j++){

			// 봄, 여름
			priority_queue<int,vector<int>,greater<int>> tmp;
			priority_queue<int,vector<int>,greater<int>> trash;
			
			while(!tree[i][j].empty()){
				int val = tree[i][j].top();
				tree[i][j].pop();
				if(val <= arr[i][j]){
					arr[i][j] -= val;
					val++;
					tmp.push(val);
				}else {
					trash.push((val/2));
				}
			}
			// 봄 나이 갱신
			tree[i][j] = tmp;
			// 여름 양분 갱신
			while(!trash.empty()){
				arr[i][j] += trash.top();
				trash.pop();
			}

			// 가을 연산
			while(!tmp.empty()){
				int val = tmp.top();
				tmp.pop();
				// 번식
				if(val %5 == 0){
					for(int s=0; s<8; s++){
						int nx = i + dx[s];
						int ny = j + dy[s];
						if(nx >= 1 && nx <=n && ny>=1 && ny<= n){
							tree[i][j].push(1);
						}
					}
				}
			}

			// 겨울 연산
			arr[i][j] += arrA[i][j];
		}
	}
}

// 나무 갯수
int ans(vector<vector<priority_queue<int,vector<int>, greater<int>>>> &tree){
	int res=0;
	for(int i=1; i<=n; i++){
		for(int j=1; j<=n; j++){
			while(!tree[i][j].empty()){
				tree[i][j].pop();
				res++;
			}
		}
	}
	return res;
}


int main() {
	cin >> n >> m >> k;
	// 땅 양분 : 5로 초기화 
	vector<vector<int>> arr(n+1, vector<int>(n+1,5));
	// 겨울에 추가되는 양분 
	vector<vector<int>> arrA(n+1, vector<int>(n+1));
	// 나무 
	vector<vector<priority_queue<int,vector<int>,greater<int>>>> tree(n+1, vector<priority_queue<int,vector<int>,greater<int>>>(n+1)); 
	
	for(int i=1; i<=n; i++){
		for(int j=1; j<=n; j++){
			cin >> arr[i][j];
		}
	}

	for(int i=0; i<m; i++){
		int x,y,z;
		cin >> x >> y >> z;
		tree[x][y].push(z);
		
	}

	// k년이 지날때까지 연산 
	for(int i=1; i<=k; i++){
		yaerFunc(arr, tree, arrA);
	}
	cout << ans(tree);
	
	return 0;
}

```
