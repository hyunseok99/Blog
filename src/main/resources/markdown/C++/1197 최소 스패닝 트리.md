---
createdAt: 2025-08-02T18:52:13.8413642
modifiedAt: 2025-08-02T18:52:13.8413642
---
- 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성 
- 입력: 첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다. 다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있다는 의미이다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.
- 최소 스패닝 트리의 가중치가 -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어진다.
- 생각 흐름
	- MST 구성을 위한 Edge struc 구현
	- union을 위한 함수 구현
	- 일반적으로 union하면 시간 초과 -> 최적 union을 위한 size 크기 필요 
- 주의
	- parents 찾는 과정에서 재귀 필요 
	

``` c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n, m;

struct Edge{
	int u,v;
	int weight;

	bool operator<(Edge& b){
		return weight < b.weight;
	}
};

int find(vector<int> &parents, int a){
	if(parents[a] == a){
		return a;
	}
	return find(parents, parents[a]);
}

bool myUnion(vector<int> &parents, vector<int> &parentsSize, Edge &e, int &weight){
	int a = find(parents, e.u);
	int b = find(parents, e.v);

	// size가 적은게 큰 쪽으로 union
	if (parentsSize[a] < parentsSize[b]){
		swab(a,b);
	}
	if ( a != b ){

		// union
		parents[b] = a;
		weight += e.weight; 
		parentsSize[a] += parentsSize[b];
		return true;
	}
	return false;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	cin >> n >> m;
	vector<Edge> edges;
	for (int i = 0; i < m; i++) {
		int a,b,c;
		cin >> a >> b>> c;
		edges.push_back({a,b,c});
	}

	sort(edges.begin(), edges.end());
		
	vector<int> parents(n+1);
	vector<int> parentsSize(n+1,1);
	for(int i=1; i<=n; i++){
		parents[i] = i;
	}
	
	int cnt=0;
	int weight = 0;
	for(auto& edge: edges){
		if(myUnion(parents, parentsSize, edge, weight)){
			cnt++;
		}
		if(cnt >= n-1) break;
	}
	cout << weight;
	return 0;
}

```
