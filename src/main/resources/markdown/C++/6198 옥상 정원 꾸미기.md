---
createdAt: 2025-08-02T18:52:15.0859718
modifiedAt: 2025-08-02T18:52:15.0859718
---
- 도시에는 N개의 빌딩이 있다.
  빌딩 관리인들은 매우 성실 하기 때문에, 다른 빌딩의 옥상 정원을 벤치마킹 하고 싶어한다.
  i번째 빌딩의 키가 hi이고, 모든 빌딩은 일렬로 서 있고 오른쪽으로만 볼 수 있다.
  i번째 빌딩 관리인이 볼 수 있는 다른 빌딩의 옥상 정원은 i+1, i+2, .... , N이다.
  그런데 자신이 위치한 빌딩보다 높거나 같은 빌딩이 있으면 그 다음에 있는 모든 빌딩의 옥상은 보지 못한다.
- 각 관리인들이 벤치마킹이 가능한 빌딩의 수의 합을 출력한다.
- 입력: 
	- 첫 번째 줄에 빌딩의 개수 N이 입력된다.(1 ≤ N ≤ 80,000)
	- 두 번째 줄 부터 N+1번째 줄까지 각 빌딩의 높이가 hi 입력된다. (1 ≤ hi ≤ 1,000,000,000)
	- 시간 제한 1초
- 생각 흐름
	- 맨 왼쪽 건물부터 오른쪽 끝 건물까지 
		- 만약 기존 건물보다 오른쪽 건물이 더 크다면 볼 수 없다.
		- 그렇지 않다면 스택에 추가 
			- 그런데 거기서 더 큰 건물들이 오른쪽에 등장했는데
				- 이 건물이 기존의 오른쪽에 위치했던 더 큰 건물 보다 크다면 다 볼 수 있음 
				- 이 끊겨지는 건물들의 높이가 핵심 
- 주의
	

``` c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int n, sum;

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	cin >> n;
	vector<long long> arr;
	stack<pair<long long, long long>> s;// height, 보이는 건물 수
	for(int i=0; i<n; i++){
		long long tmp;
		cin >> tmp;
		arr.push_back(tmp);
	}
	
	// idx에 따른 보이는 건물 수 갱신
	// 10 3 7 4 12 2
	// +2 -2 +12 +4 -4 + 7 +3 -3 -7 +10
	// {2,0,1,0,1,0}
	// 4 2 5 1 3
	// +3 +1 -1 -3 +5 +2 -2 +4
	// { 1,0,2,0,0}
	vector<long long> cnt(n); // 보이는 건물
	for(int i=n-1; i >= 0; i--){
		long long sum = 0;
		// arr[i]보다 작은 높이 건물은 보여짐 기존에 보이는 건물 + 자기 자신 
		while(!s.empty() && arr[i] > s.top().first){
			sum += (s.top().second + 1);
			s.pop();
		}
		// arr[i] <= s.top().first 
		cnt[i] = sum;
		s.push({arr[i], sum});
	}

	// 누적 합
	long long res = 0;
	for(int i=0; i < n; i++){
		// 바로 오른쪽이 더 크거나 같으면 볼 수 있는 건물 0
		if(i >= 1 && arr[i] >= arr[i-1]){
			continue;
		}else{
			// 누적합
			res += cnt[i];
		}
	}

	cout << res;
	return 0;
}

```
