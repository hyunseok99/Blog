---
createdAt: 2025-08-02T18:52:14.6359978
modifiedAt: 2025-08-02T18:52:14.6359978
---
- 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도 있다. 
- 동혁이의 여행 일정이 주어졌을 때, 이 여행 경로가 가능한 것인지 알아보자. 물론 중간에 다른 도시를 경유해서 여행을 할 수도 있다. 예를 들어 도시가 5개 있고, A-B, B-C, A-D, B-D, E-A의 길이 있고, 동혁이의 여행 계획이 E C B C D 라면 E-A-B-C-B-C-B-D라는 여행경로를 통해 목적을 달성할 수 있다.
- 동혁이의 여행 계획에 속한 도시들이 순서대로 주어졌을 때 가능한지 여부를 판별하는 프로그램을 작성
- 같은 도시를 여러 번 방문하는 것도 가능하다.
- 입력: 첫 줄에 도시의 수 N이 주어진다. N은 200이하이다. 둘째 줄에 여행 계획에 속한 도시들의 수 M이 주어진다. M은 1000이하, 마지막 줄에는 여행 계획이 주어진다
  
- 생각 흐름
	- E -> C  가능 여부 판단에 E -> A -> B -> C가 가능하다는 점이 핵심 
	- 특정 노드로의 이동으로 특정 이동이 가능한지 여부를 반환하는 함수 구현
		- 이 경우에는 한번 방문한 곳을 다시 방문할 필요가 없음 
	- 입력 받는 경로에서 첫 경로로 부터 갈 수 있는 곳을 모두 갱신하여 - 스택 이용해서 구현
		- 첫 도시부터 나머지 도시로 이동 가능 여부를 체크
		- ex) 1 -> 2 -> 3 -> 5 ->4
			- 1 -> 2 , 1 ->3, 1->5, 1 ->4 이런식으로 만약 못가는 경우 있으면 NO

- 틀렸던 포인트 
	- 자기 자신에서 자기 자신으로의 여행계획은 가능하다
	- 입력에서 자기 자신으로 입력이 0인 것에 속음 
	

``` c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

int n, m;

// 시작 도시로 부터 방문 가능한 도시들 갱신
// 입력 받는 경로에서 첫 경로로 부터 갈 수 있는 곳을 모두 갱신하여
// 첫 도시부터 나머지 도시로 이동 가능 여부를 체크
// ex) 1 -> 2 -> 3 -> 5 -> 4 에서 
// 1 -> 2 , 1 ->3, 1->5, 1 -> 4 이런식으로 만약 못가는 경우 있으면 NO
void updateConnection(vector<vector<int>> &node,int cur){

	// 없다면 해당 지점에서 이동 가능한 곳을 이용해서 연산 
	stack<int> s; // 이동 가능 도시 담을 스택
	vector<bool> flag(n+1, false); // 도시 방문 여부

	s.push(cur); 
	flag[cur] = true;
	
	while(!s.empty()){
		int from = s.top();
		s.pop();

		for(int to=1; to<=n; to++){
			if(node[from][to] == 1 && !flag[to]){
				flag[to] = true;
				s.push(to);
				// 방문 가능 경로 추가
				node[cur][to] = 1;
				node[to][cur] = 1;
			}
		}
	}
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	cin >> n >> m;
	vector<vector<int>> node(n+1, vector<int>(n+1));
	for (int i = 1; i <= n; i++) {
		for(int j = 1; j<= n; j++){
			cin >> node[i][j];
			node[j][i] = node[i][j];
			// 자기 자신으로 이동은 가능하게 수정
			if(i == j){
				node[i][j] = 1;
			}
		}
	}


	// 계획 경로 
	vector<int> plan(m);
	for(int cur=0; cur<m; cur++){
		cin >> plan[cur];
	}
	updateConnection(node, plan[0]);

	bool flag = true;
	for(int i=1; i<plan.size(); i++){
		if(node[plan[0]][plan[i]] != 1){
			flag = false;
			break;
		}
	}
	if(flag){
		cout << "YES";
	}else{
		cout << "NO";
	}
	
	return 0;
}

```
