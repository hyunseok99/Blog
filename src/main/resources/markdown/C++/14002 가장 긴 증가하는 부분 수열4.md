---
createdAt: 2025-08-02T18:52:13.9109831
modifiedAt: 2025-08-02T18:52:38.1188893
---
- 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
  예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 
  A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.
- 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.
- 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)
- 시간 제한 1초
- 생각 흐름
	- O(nlogn) ->  LIS 이용  
	- 반드시 왼쪽에 작은값 오른쪽 큰값 넣는다고 최장 수열이 되지 않음 
	- 모든 경우에 해보긴 해야 할 듯 
		- 증가하는 부분수열을 시도하면서 해당 원소의 위치를 기록해 놓아야 할 듯 
	- 결국 길이에 해당하는 seq들을 가지고 있어야 함 
- 주의
	

``` c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n, m;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	cin >> n;
	vector<int> arr(n);
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}
	
	vector<int> seq;
	vector<pair<int,int>> pos(n); // seq 길이가 n인 경우 경우의 값 : 위치

	// 처음 원소 초기화
	pos[0] = {arr[0], 0};
	seq.push_back(arr[0]);
	for(int i=1; i < arr.size(); i++){
		int val = arr[i];
		auto iter = lower_bound(seq.begin(), seq.end(), val);

		if(iter == seq.end()){
			// lis 증가 + 위치 저장
			seq.push_back(val);
			pos[i] = {val, seq.size()-1};
		}else{
			// 아닌 경우 길이 유지에 값만 변경 + 위치 저장
			*iter = val;
			pos[i] = {val, iter - seq.begin()};

		}
	}

	// pos에는 i번째 원소의 위치가 저장되어 있음 이를 이용해 LIS ㄱㄱ
	vector<int> lis;
	int cur = seq.size() - 1; // seq 최종본의 idx
	for(int i = n-1; i >= 0; i--){
		// pos[i]의 삽입 idx가 cur와 같을 때
		if(pos[i].second == cur){
			// pos[i].first가 lis에 존제 힌다면 이전에 넣은 원소보다 작아야 함 
			// 만약 lis가 비어있으면 처음에 추가
			if(lis.empty()||pos[i].first < lis.back()){
				lis.push_back(pos[i].first); 
				cur--;
			}
		}

		// cur < 0 종료
		if(cur < 0) break;
	}
	
	// 현재 lis에는 끝부터 존재 
	cout << lis.size() << "\n";
	for(int i = lis.size()-1; i >= 0; i--){
		cout << lis[i] << " ";
	}
	return 0;
}

```
