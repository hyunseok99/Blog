---
createdAt: 2025-08-02T18:52:14.6026938
modifiedAt: 2025-08-02T18:52:14.6026938
---
- 두 사람 모두 상대방이 자기보다 1원이라도 더 받는 것은 도저히 인정할 수 없어 한다. 따라서 돈을 똑같이 둘로 나누어 가져야 두 사람이 모두 만족할 수 있게 된다.
- 예를 들어 500원짜리 1개와 50원짜리 1개를 받았다면, 이 돈을 두 사람이 똑같이 나누어 가질 수는 없다. 물론 동전을 반으로 잘라서 나누어 가질 수도 있겠지만 그러면 돈으로서의 가치를 잃기 때문에 그렇게 할 수는 없다.
- 원장 선생님께서 N가지 종류의 동전을 각각 몇 개씩 주셨을 때, 그 돈을 반으로 나눌 수 있는지 없는지 판단하라
- 입력: 
  세 개의 입력이 주어진다. 각 입력의 첫째 줄에 동전의 종류 N(1 ≤ N ≤ 100)이 주어진다. 각 입력의 둘째 줄부터 N+1째 줄까지 각각의 동전의 금액과 개수가 빈 칸을 사이에 두고 주어진다. 단, 원장선생님께서 주신 금액의 총 합은 100,000원을 넘지 않는다. 동전의 금액과 개수는 자연수이고, 같은 금액을 가진 동전이 두 번 이상 주어지는 경우는 없다.
- 생각 흐름
	- 전체 금액의 절반을 조합을 통해 구현 가능한가
	- 더하다가 절반의 금액 넘으면 stop 
	-  1 + 1 + 1 + 1 + 1 =  1 + 1 + 1+ 2 = 1 + 2 + 2 = 5 이런식
- 주의
	- 로그 분할 기법으로 dp 탐색 범위를 최적화 해야 함 
		- 1원 동전이 10만개가 넘는다면 for문 10만번 돌아야 해서 3중 for문 돌면 초과 
		- 1,2,4,8 ... 2의 거듭제곱의 형태로 분할 하면 1~N까지 모든 수를 만들 수 있음. 
	

``` c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n;


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	for (int i = 0; i < 3; i++) {
		cin >> n;
		// 동전 가격,  갯수
		vector<pair<int,int>> value;
		int obj = 0;
		for(int j = 0; j < n; j++){
			int a,b;
			cin >> a >> b;
			value.push_back({a, b});
			obj += (a*b);
		}
		// 가능 금액
		vector<bool> dp(obj +1, false);
		dp[0] = true; 
		// 반반 불가
		if(obj % 2 != 0){
			cout << 0 << "\n";
			continue;
		}

		obj = obj/2;

		// dp로 반 나누기 가능한지 검증
		for(int i=0; i< value.size(); i++){
			pair<int,int> coin = value[i];
			int price = coin.first;
			int cnt = coin.second;

			for(int j=0; j < cnt; j++){
				for(int k= obj; k >= price; k--){
					if(dp[k-price]){
						dp[k] = true;
					}
				}
			}
		}

		if(dp[obj]){
			cout << 1 << "\n";
		}else{
			cout << 0 << "\n";
		}
	}

	
	return 0;
}

```
