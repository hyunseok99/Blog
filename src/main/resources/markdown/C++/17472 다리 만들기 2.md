---
createdAt: 2025-08-02T18:52:14.4592624
modifiedAt: 2025-08-02T18:52:14.4592624
---
- 섬으로 이루어진 나라가 있고, 모든 섬을 다리로 연결하려고 한다. 이 나라의 지도는 N×M 크기의 이차원 격자로 나타낼 수 있고, 격자의 각 칸은 땅이거나 바다이다. 
- 섬은 연결된 땅이 상하좌우로 붙어있는 덩어리를 말하고, 색칠되어있는 칸은 땅이다
- 다리는 바다에만 건설할 수 있고, 다리의 길이는 다리가 격자에서 차지하는 칸의 수이다. 다리를 연결해서 모든 섬을 연결하려고 한다. 섬 A에서 다리를 통해 섬 B로 갈 수 있을 때, 섬 A와 B를 연결되었다고 한다. 다리의 양 끝은 섬과 인접한 바다 위에 있어야 하고, 한 다리의 방향이 중간에 바뀌면 안된다.
  또, 다리의 길이는 2 이상이어야 한다.
- 다리의 방향이 중간에 바뀌면 안되기 때문에, 다리의 방향은 가로 또는 세로가 될 수 밖에 없다. 방향이 가로인 다리는 다리의 양 끝이 가로 방향으로 섬과 인접해야 하고, 방향이 세로인 다리는 다리의 양 끝이 세로 방향으로 섬과 인접해야 한다.
- 섬 A와 B를 연결하는 다리가 중간에 섬 C와 인접한 바다를 지나가는 경우에 섬 C는 A, B와 연결되어있는 것이 아니다.
- 다리가 교차하는 경우가 있을 수도 있다. 교차하는 다리의 길이를 계산할 때는 각 칸이 각 다리의 길이에 모두 포함되어야 한다.
- 모든 섬을 연결하는 다리 길이의 최솟값을 출력한다. 모든 섬을 연결하는 것이 불가능하면 -1을 출력한다.
- 입력: 첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 지도의 정보가 주어진다. 각 줄은 M개의 수로 이루어져 있으며, 수는 0 또는 1이다. 0은 바다, 1은 땅을 의미한다.
- 제약:
	- 시간 제한 1초 
	- - 1 ≤ N, M ≤ 10
	- 3 ≤ N×M ≤ 100
	- 2 ≤ 섬의 개수 ≤ 6
- 
- 생각 흐름
	- 섬들이 연결을 형성하는 경우를 정해 놓고 최단 거리 계산
		- ex) 1,2,3번 : (1,2) 사이에 다리, (2,3)사이에 다리 or (1,2)사이, (1,3) or (1,3) (2,3) 
		- 1,2,3,4,5: 1,2 1,3 1,4 ,1,5
	- 단순 생각으로는 놓는 다리의 수가 최소일 때 최단 
		- 예외의 경우가 있나? x
	- 다리를 놓을 곳을 정해 놓고 최단이 되는 경우 계산 
		- 연결은 가로와 세로로 연산 후 최단의 경우 
	- 하다 보니 각 섬에서 다른 섬들에게 연결 가능한 최단 거리를 기록해서 
		- 그 조합으로 최단을 구현 하는게 더 나아 보여 수정 
	- 마지막에 특점 섬에서 가능한 모든 최단 거리를 구한걸 보니
		-  최소 스패닝 트리 형성 가능하면 가능 아니면 -1

	

``` c++
#include <iostream>
#include <vector>
#include <queue>
#include <utility>
using namespace std;

int n, m;

// 상 하 좌 우
int dy[4] = {-1, 1, 0, 0};
int dx[4] = {0, 0, -1, 1};

// 섬 구분 짓기
void numbering(int y, int x, int &num, vector<vector<int>> &arr){
	queue<pair<int,int>> q;
	q.push({y,x});
	while(!q.empty()){
		pair<int,int> tmp = q.front();
		q.pop();
		if(arr[tmp.first][tmp.second] == num) continue;
		// 섬 넘버링 2~x
		arr[tmp.first][tmp.second] = num;
		for(int dir = 0; dir < 4; dir++){
			int ny = tmp.first + dy[dir];
			int nx = tmp.second + dx[dir];
			if(ny >= 0 && ny < n && nx>=0 && nx < n && arr[ny][nx] == 1){
				q.push({ny, nx});
			}
		}
	}
	num++;
	return;
}


// 특정 섬에서 다른 섬까지 다리 건설 여부 및 가능한 경우 최단 길이 갱신
void getDist(vector<vector<int>> &dist, vector<vector<int>> &arr, int num){
	vector<vector<bool>> flag(n,vector<bool>(m, false));
	// 2번 섬부터 num-1번 섬까지 
	for(int i=2; i < num-1; i++){
		int cur = i; // 현재 선택 섬 
		for(int j = i+1; j < num; j++){
			int connected = j;

			// i,j 섬 사이의 최단 거리 
			for(int y = 0; y < n; y++){
				for(int x =0; x < m; x++){
					if(arr[y][x] == i && !flag[y][x]){
						flag[y][x] = true;
						// 가로의 경우 
						int distX = 0;
						int startY = y;
						int startX = x;
						bool isConnected = false;
						// 증가하는 경우
						while(startX < n){
							startX++;
							if(arr[y][startX] == i && distX == 0){
								flag[y][startX] = true;
							}else if(arr[y][startX] == 0){
								distX++;
							}else if(arr[y][startX] == connected){
								isConnected = true;
								break;
							}else{
								// 육지를 지나가 다리 놓기 불가
								break;
							}
						}
						
						if(isConnected && distX > 1){
							dist[i][j] = min(dist[i][j], distX);
							dist[j][i] = min(dist[j][i], distX);
						}
						// 감소하는 경우
						startX = x;
						distX = 0;
						isConnected = false;
						while(startX > 0){
							startX--;
							// ㅂ 형태의 땅일 경우 다리 x 
							if(arr[y][startX] == i && distX == 0){
								flag[y][startX] = true;
							}else if(arr[y][startX] == 0){
								distX++;
							}else if(arr[y][startX] == connected){
								isConnected = true;
								break;
							}else{
								// 육지를 지나가 다리 놓기 불가
								break;
							}
						}
						if(isConnected && distX > 1){
							dist[i][j] = min(dist[i][j], distX);
							dist[j][i] = min(dist[j][i], distX);
						}

						// 세로
						int distY = 0;
						isConnected = false;
						while(startY < n){
							startY++;
							if(arr[startY][x] == i && distY == 0){
								flag[startY][x] = true;
							}else if(arr[startY][x] == 0){
								distY++;
							}else if(arr[startY][x] == connected){
								isConnected = true;
								break;
							}else{
								// 육지를 지나가 다리 놓기 불가
								break;
							}
						}
						if(isConnected && distY > 1){
							dist[i][j] = min(dist[i][j], distY);
							dist[j][i] = min(dist[j][i], distY);
						}
				
						distY = 0;
						isConnected = false;
						while(startY > 0){
							startY--;
							if(arr[startY][x] == i && distY == 0){
								flag[startY][x] = true;
							}else if(arr[startY][x] == 0){
								distY++;
							}else if(arr[startY][x] == connected){
								isConnected = true;
								break;
							}else{
								// 육지를 지나가 다리 놓기 불가
								break;
							}
						}
						if(isConnected && distY > 1){
							dist[i][j] = min(dist[i][j], distY);
							dist[j][i] = min(dist[j][i], distY);
						}
					}
				}
			}
		} 
	}
}

struct Edge{
	int u,v; 
	int weight;

	bool operator<(Edge &b) const{
		return weight < b.weight;
	}
};

class DSU{
public:
	vector<int> parents;
	int components; // 연결된 수
	
	DSU(int n){ // 2~ n-1 번 섬 
		parents.resize(n);
		for(int i=2; i<n; i++){
			parents[i] = i;
		}
		components = n-2;
	}

	int findRoot(int v){
		if(v == parents[v]) return v;
		return parents[v] = findRoot(parents[v]);
	}

	bool unionSet(int a, int b){
		a = findRoot(a);
		b = findRoot(b);

		if( a != b){
			parents[b] = a;
			components--;
			return true;
		}
		return false;
	}
};

// 섬 조합 구하기 -> 최소 스패닝 트리 구현 가능 여부로 
int MST(vector<vector<int>> dist, int num){
	int res = -1;
	vector<Edge> edges;
	for(int i=2; i < num-1; i++){
		for(int j=i+1; j < num; j++){
			if(dist[i][j] != 101){ // 101이면 연결 불가
				edges.push_back({i, j, dist[i][j]});
			}
		}
	}

	// 크루스칼 
	sort(edges.begin(), edges.end());

	DSU dsu(num);
	int weight = 0;

	for(auto& edge: edges){
		// 유니온 가능하면
		if(dsu.unionSet(edge.u, edge.v)){
			res += edge.weight;
		}

		// mst 생성 여부 확인
		if(dsu.components == 1){
			break;
		}
	}

	if(dsu.components == 1){
		return weight;
	}else{
		return -1;
	}
}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	cin >> n >> m;
	vector<vector<int>> arr(n , vector<int>(m));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++){
			cin >> arr[i][j];
		}
	}

	// 섬 구분하기 1,2,3 ... x개의 섬을 구분 
	int num = 2; // 섬은 2 ~ (num-1) 까지 존재
	for(int i=0; i<n; i++){
		for(int j=0; j<m; j++){
			if(arr[i][j] == 1){
				numbering(i, j, num, arr);
			}
		}
	}

	// 다리를 놓을 섬들의 조합을 구성 및 거리 계산 
	vector<vector<int>> dist(num,vector<int>(num, 101)); // 2~ (num-1)번 까지의 다리 설치시 최단 거리 저장 
	getDist(dist, arr, num);

	int res = -1;
	cout << getMinComb(dist);
	return 0;
}

```
