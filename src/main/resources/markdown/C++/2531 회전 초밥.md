---
createdAt: 2025-08-02T18:52:14.8719277
modifiedAt: 2025-08-02T18:52:14.8719277
---
- 회전 초밥 음식점의 벨트 상태, 메뉴에 있는 초밥의 가짓수, 연속해서 먹는 접시의 개수, 쿠폰 번호가 주어졌을 때, 손님이 먹을 수 있는 초밥 가짓수의 최댓값을 구하는 프로그램을 작성하시오.

- 생각 흐름
	- 1. 초밥 쿠폰 번호가 초밥 벨트에 존재하는지 여부 -> 이후 구현 과정에서 초기에 조건 필요 x
	- 2. 연속으로 k개 먹을 때 최대한 다양한 음식 구하는 로직
		- 시간 고려 할 때 연산 최소화 해야 하는 부분이라고 생각
		- 이전의 연산을 활용해서 효율 높여보자고 생각 ex) 1~k  연산이  2~k+1 까지 연산에 활용 
			- sliding window 느낌 
			- 양쪽 끝 투포인터로 고려 
			  
		
``` c++
#include <iostream>
#include <unordered_map>
using namespace std;

int[30001] belt;
unordered_map<int, int> myMap;
int res_max = -1;

void getMax(int n, int k, int c) {
	for(int i=1; i<=n; i++){
		int last = (i+k);
		if(last > n){
			last = last - n;
		}
		
		myMap[i] = myMap[i] - 1;

		myMap[last] = myMap[last] + 1;

		int tmp = myMap.size();
		
		if(myMap[c] == 0){
			tmp = tmp + 1;
		}
		if(res_max < tmp) res_max = tmp;
	}
	return;
}

int main() {
	int n,d,k,c;
	bool coupon = false;
	cin>>n>>d>>k>>c;
	for(int i=1; i<=n; i++) {
		int type;
		cin>>type;
		belt[i] = type;
		if(i <= k){
			if(myMap[type] != 0) {
				myMap[type] = myMap[type] + 1;
			}else {
				myMap[type] = 1;
			}
		}
	}
	if(myMap[c] == 0){
		res_max = myMap.size() + 1;
	}else {
		res_max = myMap.size();
	}
	getMax(n,k,c);
	cout << res_max;
	return 0;	
}
```
