---
createdAt: 2025-08-02T18:52:14.5792086
modifiedAt: 2025-08-02T18:52:14.5792086
---
- 총 25명의 여학생들로 이루어진 여학생반은 5×5의 정사각형 격자 형태로 자리가 배치
- 모든 여학생이 ‘이다솜파’와 ‘임도연파’의 두 파로 갈라지게 되었으며
- ‘이다솜파’의 학생들은 과감히 현재의 체제를 포기하고, ‘소문난 칠공주’를 결성
	1. 이름이 이름인 만큼, 7명의 여학생들로 구성되어야 한다.
	2. 강한 결속력을 위해, 7명의 자리는 서로 가로나 세로로 반드시 인접해 있어야 한다.
	3. 화합과 번영을 위해, 반드시 ‘이다솜파’의 학생들로만 구성될 필요는 없다.
	4. 그러나 생존을 위해, ‘이다솜파’가 반드시 우위를 점해야 한다. 따라서 7명의 학생 중 ‘이다솜파’의 학생이 적어도 4명 이상은 반드시 포함되어 있어야 한다.
- 여학생반의 자리 배치도가 주어졌을 때, ‘소문난 칠공주’를 결성할 수 있는 모든 경우의 수를 구하는 프로그램을 작성


- 생각 흐름
	- 구성 이후에 과반수가 '이다솜파'
		- 구성과정에서 '임도연파'가 4명 이상이 되면 해당 경우 탐색 종료 
		- 특정 지점에서 4방향 모두를 포함 시키기도 가능하기에 포함 갯수도 고려 필요
		- 큐를 활용해서 dfs 구현  
		- 모든 점을 시작지점으로 
		- 중복되는 경우 고려 필요 
			- 시작점들을 순회할 때 이 순회한 경우는 이미 방문을 고려하여 중복 제거 
- 주의사항
	- string의 idx접근할 때 char형 의식 

``` c++
#include <iostream>
#include <vector>
#include <utility>
#include <string>
#include <queue>
#include <algorithm>
using namespace std;

int n = 5;


// 상하좌우
int dx[4] = { -1, 1, 0, 0 };
int dy[4] = { 0, 0, -1, 1 };

// 중복 여부 체크

// cntS: 포함한 S 갯수 , cntY: 포함한 Y 갯수 
int getRes(vector<string>& arr) {
	// res: 가능 가짓수
	int res = 0;

	// 7개 포함 조합의 경우 생성하기 : 정렬 필요 
	vector<int> comb;
	for (int i = 0; i < 25; i++) {
		if (i < 7){
			comb.push_back(1); 
		}
		else {
			comb.push_back(0);
		}
	}
	sort(comb.begin(), comb.end());

	do {
		queue<pair<int, int>> q;
		// 방문 체크용
		vector<vector<bool>> flag(n, vector<bool>(n, false));

		// 25개중 선택된 7명의 위치 체크용 
		vector<vector<bool>> selected(n, vector<bool>(n, false));

		// line: 인접한 사람 수, cntS: S그룹 인원
 		int line = 0;
		int cntS = 0; 

		for (int i = 0; i < 25; i++) {
			// 선택된 7명의 idx
			if (comb[i] == 1) {
				int x = i / 5;
				int y = i % 5;
				selected[x][y] = true;		
				// 중복 방지
				if (q.empty()) {
					q.push({ x, y });
					flag[x][y] = true;
				}
			}

		}

		while (!q.empty()) {
			int x = q.front().first;
			int y = q.front().second;
			q.pop();
			line++;

			if (arr[x][y] == 'S') {
				cntS++;
			}

			for (int dir = 0; dir < 4; dir++) {
				int nx = x + dx[dir];
				int ny = y + dy[dir];
				if (nx >= 0 && nx < n && ny >= 0 && ny < n) {
					// 선택된 노드이며 방문하지 않은 경우에 push
					if (!flag[nx][ny] && selected[nx][ny]) {
						q.push({ nx, ny });
						flag[nx][ny] = true;
					}
				}
			}
		}

		if (line >= 7 && cntS >= 4) {
			res++;
		}

	} while (next_permutation(comb.begin(), comb.end()));

	return res;
}


int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	vector<string> arr;

	for (int i = 0; i < n; i++) {
		string tmp;
		cin >> tmp;
		arr.push_back(tmp);
	}
	
	cout << getRes(arr);

	return 0;
}
```
