---
createdAt: 2025-08-02T18:52:14.4859778
modifiedAt: 2025-08-02T18:52:14.4859778
---
- 일직선상에 놓여 있는 볼에 관한 정보가 주어질 때, 규칙에 따라 볼을 이동하여 같은 색끼리 모으되 최소 이동횟수를 찾는 프로그램을 작성하시오.

- 생각 흐름
	- 옮길 색의 종류 정하고 -> 이동 가능 여부 판단 후 연산
	- 옮겨야 하는 경우 같은 색의 연속은 전부 옮겨야 되므로 연속되는 값 이용하면 좋을 듯 
	- 연속되는 갯수를 이용해서 총 스트릭이 짝수개인지, 홀수개인지에 따라 연산 
		- 연속되는 값이 짝수, 홀수개인지에 따라 결과 계산
	- 홀수개인 경우에는 왼쪽 또는 오른쪽으로  이동에 따라 결과 달라짐
	

``` c++
#include <iostream>
#include <unordered_map>
using namespace std;

int n;
int res;
string ball;

void fun(){
	vector<int> v;
	int strick = 0;
	char color = ball[0];
	for(int i=0; i<ball.size(); i++){
		if(ball[i] == color){
			strick += 1;
			if (i == ball.size() - 1) {
				v.push_back(strick);
			}
		}else{
			v.push_back(strick);
			color = ball[i];
			strick = 1;
			if (i == ball.size() - 1) {
				v.push_back(strick);
			}
		}
	}

	// 정답 연산
	int even = 0;
	int odd= 0;

	for (int i = 0; i < v.size(); i++) {
		if ((i % 2) == 0) {
			even += v[i];
		}
		else {
			odd += v[i];
		}
	}

	if (v.size() % 2 == 0) { // 짝수개인 경우 
		int tmpFirst = even - v[0];
		int tmpSecond = odd - v[v.size() - 1];
		res = min(tmpFirst, tmpSecond);
	}
	else { // 홀수개인 경우 -> 왼쪽이동 또는 오른쪽 이동  
		int tmpFirst = min((even - v[0]), (even - v[v.size() - 1]));
		int tmpSecond = odd;
		res = min(tmpFirst, tmpSecond);
	}

}

int main(){
	cin >> n >> ball;
	fun();
	cout<<res;
	return 0;
}

```
