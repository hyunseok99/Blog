---
createdAt: 2025-08-02T18:52:14.7613877
modifiedAt: 2025-08-02T18:52:14.7613877
---
- 치르보기 빌딩은 1$1$층부터 N$N$층까지 이용이 가능한 엘리베이터가 있다. 엘리베이터의 층수를 보여주는 디스플레이에는 K$K$ 자리의 수가 보인다. 수는 0$0$으로 시작할 수도 있다.
- 각 숫자는 7개의 표시등 중의 일부에 불이 들어오면서 표현된다.
- 최소 1$1$개, 최대 P개를 반전시킬 계획을 세우고 있다, 반전이란 켜진 부분은 끄고, 꺼진 부분은 켜는 것
- 현재 엘리베이터가 실제로는 X층에 멈춰있을 때, 호석이가 반전시킬 LED를 고를 수 있는 경우의 수를 계산해보자.

- 입력: N, K, P, X 가 공백으로 구분되어 첫째 줄에 주어진다
- 출력: 호석 빌런이 엘리베이터 LED를 올바르게 반전시킬 수 있는 경우의 수를 계산해보자.
- 생각 흐름
	- 각 수의 7개의 led 값을 가지고 비교를 통해서 반전을 처리해야 할 듯
	- x에서 다른 층과의 차이 led 갯수를 가지고 비교하면 될 듯 
	

``` c++
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;

int n, k, p, x;
int res;

// 위에서부터 아래로, 왼쪽에서 오른쪽으로 led idx 처리
// 0 -> off, 1 -> on
int led[10][7] = {{1, 1, 1, 0, 1, 1, 1},{0, 0, 1, 0, 0 ,1 ,0},{1, 0, 1, 1, 1 ,0 ,1},{1, 0, 1, 1, 0 ,1 ,1},{0, 1, 1, 1, 0 ,1 ,0},{1, 1, 0, 1, 0 ,1 ,1},{1, 1, 0, 1, 1 ,1 ,1},{1, 0, 1, 0, 0 ,1 ,0},{1, 1, 1, 1, 1 ,1 ,1},{1, 1, 1, 1, 0 ,1 ,1}
};

// x가 아닌 다른 충과의 led 차이 갯수를 확인해서 p개 이하면 정답 +1 
void action(vector<int> arrN, vector<int> arr) {
	int changes = 0;
	for(int i=0; i< arr.size(); i++){
		int arrLed = arr[i];
		int arrNLed = arrN[i];
		for(int j=0; j <7; j++){
			if(led[arrLed][j] != led[arrNLed][j]) {
				changes++;
			}
		}
	}
	if(changes <= p) res++;
}

// n: 1~n 층 , k: 디스플레이 k자리, p: 최대 p개 반전 x: 실제 층
int main() {
	cin >> n >> k >> p >> x;

	// 실제 층의 분해 ex) k=4, n=300, x = 107 -> 0107
	vector<int> arr;
	int val = x;
	for(int i=k-1; i >=0; i--){
		int tmp = val / pow(10, i);
		val -= (tmp * pow(10,i));
		arr.push_back(tmp);	  
	}

	for(int i=1; i<=n; i++){
		if(i == x) continue;
		vector<int> arrN;
		int val = i;
		for(int j=k-1; j >= 0; j--){
			int tmp = val / pow(10, j);
			val -= (tmp * pow(10,j));
			arrN.push_back(tmp);	    
		}
		action(arrN, arr);
	}

	cout << res;
	return 0;
}

```
