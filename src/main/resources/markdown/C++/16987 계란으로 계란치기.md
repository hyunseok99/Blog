---
createdAt: 2025-08-02T18:52:14.2215969
modifiedAt: 2025-08-02T18:52:14.2225934
---
- 각 계란에는 내구도와 무게가 정해져있다.
- 계란으로 계란을 치게 되면 각 계란의 내구도는 상대 계란의 무게만큼 깎이게 된다. 그리고 내구도가 0 이하가 되는 순간 계란은 깨지게 된다.
- 계란에 대해 왼쪽부터 차례로 들어서 한 번씩만 다른 계란을 쳐 최대한 많은 계란을 깨는 문제
	1. 가장 왼쪽의 계란을 든다.
	2. 손에 들고 있는 계란으로 깨지지 않은 다른 계란 중에서 하나를 친다. 단, 손에 든 계란이 
	   깨졌거나 깨지지 않은 다른 계란이 없으면 치지 않고 넘어간다. 이후 손에 든 계란을 원래 자리에 내려놓고 3번 과정을 진행한다.
	3. 가장 최근에 든 계란의 한 칸 오른쪽 계란을 손에 들고 2번 과정을 다시 진행한다. 
	   단, 가장 최근에 든 계란이 가장 오른쪽에 위치한 계란일 경우 계란을 치는 과정을 종료한다.
- 일렬로 놓인 계란들의 내구도와 무게가 차례대로 주어졌을 때 최대 몇 개의 계란을 깰 수 있는지
- 입력:
	- 첫째 줄에 계란의 수를 나타내는 N
	- 그 다음 N개의 줄에는 계란의 내구도와 무게에 대한 정보가 주어진다
- 생각 흐름
	- 더 이상 깰 수 없는 상태가 되었을 때 기록하고 이전 상황으로 돌아가서 다른 경우가 있으면 시도하는 방식으로 구현 하면 될 듯
	- 무조건 한번 깨고 나서 원위치, 
	

``` c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n;
int res = 0;
struct egg {
	int weight;
	int durability;
};

// 손에든 계란이 깨졌거나 칠 다른 계란이 없는 경우
bool check(int mine, vector<bool>& flag) {
	if (flag[mine]) return true;

	int cnt = 0;
	for (int i = 0; i < n; i++) {
		if (i == mine) continue;
		if (!flag[i]) {
			cnt++;
		}
	}
	if (cnt == 0) return true;
	return false;
}

// flag가 true면 스킵
// mine: 들고 있는 계란 idx
// other: 꺨 계란 idx 
void backTracking(int mine, vector<egg> &arr, vector<bool> &flag) {
	// 마지막 계란으로 행위를 한 후 혹은 더이상 칠 계란이 없는 경우
	if (mine == n) {
		int cnt = 0;
		for (int i = 0; i < n; i++) {
			if (flag[i] == true) {
				cnt++;
			}
		}
		res = max(res, cnt);

		return;
	}

	// 선택된 계란이 이미 깨지거나 더이상 깰 계란이 없는 경우
	if (check(mine, flag)) {
		backTracking(mine + 1, arr, flag);
		return;
	}

	// 깰 계란 선택
	for (int other = 0; other < n; other++) {
		// 만약 깰 계란과 선택된 계란이 같으면 continue;
		if (mine == other) { 
			continue; 
		}
		else {
			// 꺨 계란이 이미 깨진 상태라면 continue;
			if (flag[other]) continue;
			else {
				arr[mine].durability -= arr[other].weight;
				arr[other].durability -= arr[mine].weight;
				if (arr[mine].durability > 0 && arr[other].durability <= 0) {
					// 상대만 꺠짐
					flag[other] = true;
					backTracking(mine + 1, arr, flag);
					flag[other] = false;
				}
				else if (arr[mine].durability > 0 && arr[other].durability > 0) {
					// 둘다 안깨짐
					backTracking(mine + 1, arr, flag);

				}
				else if (arr[mine].durability <= 0 && arr[other].durability > 0) {
					// 내꺼만 깨짐
					flag[mine] = true;
					backTracking(mine + 1, arr, flag);
					flag[mine] = false;

				}
				else {
					// 둘다 깨짐
					flag[mine] = true;
					flag[other] = true;
					backTracking(mine + 1, arr, flag);
					flag[mine] = false;
					flag[other] = false;
				}
				arr[mine].durability += arr[other].weight;
				arr[other].durability += arr[mine].weight;
			}
		}
		
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	cin >> n;
	vector<egg> arr;
	// 깨짐 여부: 
	vector<bool> flag(n, false);
	for (int i = 0; i < n; i++) {
		egg tmp;
		cin >> tmp.durability >> tmp.weight;
		arr.push_back(tmp);
	}
	backTracking(0, arr, flag);

	cout << res;

	return 0;
}

```
