---
createdAt: 2025-08-02T18:52:14.787726
modifiedAt: 2025-08-02T18:52:38.866295
---
- 일직선으로 다양한 높이의 건물이 총 N개가 존재한다. 각 건물 옥상에서 양 옆에 존재하는 건물의 옆을 몇 개 볼 수 있는지 궁금해졌다.

 - i번째 건물 기준으로 i−1,i - 1, i−2, i - 2, ..., 1번째 건물은 왼쪽에, i+1, i + 1, i+2, i + 2, ..., N번째 건물은 오른쪽에 있다. 각 건물 사이의 거리는 다 동일하다.

- 현재 있는 건물의 높이가 L이라고 가정하면 높이가 L보다 큰 곳의 건물만 볼 수 있다.
- 바라보는 방향으로 높이가 L인 건물 뒤에 높이가 L이하인 건물이 있다면 가려져서 보이지 않는다.
- 각 건물에서 볼 수 있는 건물들이 어떤것이 있는지 구해보자.
- 1<= N, L <= 100,000

- 생각 흐름
	- 볼 수 있는 거리가 같은 경우 번호가 작은 것 출력 
	- 좌, 우 + 거리 고려 필요함 
	- 볼 수 있는 갯수 갱신하려면 방향별  최고 높이가 필요함 
	- idx 기준 보이는 경우 보관 필요 
	- idx-1에서 왼쪽, 오른쪽 볼 수 있는 경우 vector에 보관 해놓고
		- idx기준 idx-1 보다 작은 경우 큰 경우 고려 
	- 최적화를 고려하면 스택이용해서 복사 최소화 하고 갱신

	

``` c++
#include <iostream>
#include <vector>
#include <cmath>
#include <utility>
#include <stack>
using namespace std;

int n;

struct tower{
	int height;
	int ans = 0;
	int leftTop = -1;
	int rightTop = -1;
};

void move(vector<tower> &v, stack<int> &leftSee, stack<int> &rightSee){
	// 왼쪽에 볼 수 있는 경우
	for(int i=2; i <= n; i++){
		if(v[i].height < v[i-1].height){
			// 현재 빌딩이 이전 빌딩 보다  작은 경우
			leftSee.push(i-1);
		}else{
			// 현재 빌딩이 이전 빌딩 보다 큰 경우 
			// 이전에 보이던 것 중 현재 빌딩보다 작거낙 같은것 제외 
			while(!leftSee.empty() && (v[leftSee.top()].height <= v[i].height)){
				leftSee.pop();
			}
		}
		v[i].ans += leftSee.size();
		if(!leftSee.empty()){
			v[i].leftTop = leftSee.top();
		}
	}

	// 오른쪽에 볼 수 있는 경우 
	for(int i = n-1;  i >= 1; i--){
		// 현재 빌딩이 오른쪽 빌딩 보다 작은 경우
		if(v[i].height < v[i+1].height){
			rightSee.push(i+1);
		} else{
			// 현재 빌딩이 오른쪽 빌딩 보다 큰 경우
			// 이전에 보이던 것 중 현재보다 작거나 같은것 제외 
			while(!rightSee.empty()&&(v[rightSee.top()].height <= v[i].height)){
				rightSee.pop();
			}
		}
		v[i].ans += rightSee.size();
		if(!rightSee.empty()){
			v[i].rightTop = rightSee.top();
		}
	}
	
}

void getRes(vector<tower> &v){
	for(int i=1; i<=n; i++){
		if(v[i].ans == 0){
			cout << 0 << "\n";
		}else{
			if(v[i].leftTop == -1){
				cout << v[i].ans << " " << v[i].rightTop << "\n";
			}else if(v[i].rightTop == -1){
				cout << v[i].ans << " " << v[i].leftTop << "\n";
			}else{
				if(abs(i-v[i].leftTop) <= abs(i-v[i].rightTop)){
					cout << v[i].ans << " " << v[i].leftTop << "\n";
				}else{
					cout << v[i].ans << " " << v[i].rightTop << "\n";
				}
			}
		}
	}
}


int main() {
	cin >> n;
	vector<tower> v(n+1);
	for (int i = 1; i <= n; i++) {
		cin >> v[i].height;
	}

	// 왼쪽으로 보이는 빌딩, 오른쪽으로 보이는 빌딩 
	stack<int> leftSee;
	stack<int> rightSee;
	
	move(v, leftSee, rightSee);
	
	getRes(v);
	
	return 0;
}

```
