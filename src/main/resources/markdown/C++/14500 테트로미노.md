---
createdAt: 2025-08-02T18:52:14.0069878
modifiedAt: 2025-08-02T18:52:38.2013739
---
- 폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.
	- 정사각형은 서로 겹치면 안 된다.
	- 도형은 모두 연결되어 있어야 한다.
	- 정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.
- 정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 5가지가 있다.
- 아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.
- 테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.
- 테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.
- 입력 값: 첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500),
   둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.
- 출력 값: 첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.

- 생각 흐름
	- 특정 지점에서 상,하,좌,우로 4번 이동 했을 때의 누적 값이 가능한 값 모든 지점에서 가능한 값들을 모두 비교 ->  복잡도가 n x m x 4^4  , 최대 500 x 500 x 256 
	- 기존의 이동을 활용한4개 선택으로는 凸 모양의 경우를 체크 못하니 결국 이걸 체크 하는게 핵심
	- 凸 모양을 특수하게 체크 하도록 추가 
- 문제 해결
	-  방향 체크하고 재귀 종료하는 과정에서 return을 해버리는 바람에 문제가 생겼었음
	  return이 아니라 continue로 다른 방향을 계속 관리했어야 하는데 


``` c++
#include <iostream>
#include <vector>
#include <algoithm>
using namespace std;

int n, m;
int res = -1;

// 상하좌우
int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};

int check(int[3] dir,int x, int y, vector<vector<int>> &arr){
	int sum = 0;
	for(int i=0; i<3; i++){
		int nx = x + dx[dir[i]];
		int ny = y + dy[dir[i]];
		if(nx>=0 && nx < n && ny >=0 && ny < m) {
			sum += arr[nx][ny];
		}else{
			return -1;
		}
	}
	return sum;
}

void move(int lev, int x, int y, vector<vector<int>> &arr, vector<vector<bool>> &flag, int sum) {
	if(lev == 4){
		res = max(res, sum);
		return;
	}
	for(int i = 0; i < 4; i++){
		int nx = x + dx[i];
		int ny = y + dy[i];
		if(nx >= 0 && nx < n && ny >= 0 && ny < m){
			if(flag[nx][ny] == true){
				continue;
			}
			flag[nx][ny] = true;
			move(lev+1, nx, ny, arr, flag, sum + arr[nx][ny]);
			flag[nx][ny] = false; 
		}
	}
	return; 
} 

int main() {
	cin >> n >> m;
	vector<vector<int>> arr(n, vector<int>(m));
	vector<vector<bool>> flag(n, vector<bool>(m));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> arr[i][j];
		}
	}

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			int sum0 = check({0,1,2}, i, j, arr);
			int sum1 = check({0,1,3}, i, j, arr);
			int sum2 = check({0,2,3}, i, j, arr);
			int sum3 = check({1,2,3}, i, j, arr);
			res = max(res, sum0);
			res = max(res, sum1);
			res = max(res, sum2);
			res = max(res, sum3);
			
			flag[i][j] = true;
			move(0, i, j, arr, flag, arr[i][j]);
			flag[i][j] = false;
		}
	}
	
	cout << res; 
	return 0;
}

```
