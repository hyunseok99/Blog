---
createdAt: 2025-08-02T18:52:14.8110117
modifiedAt: 2025-08-02T18:52:14.8110117
---
- 1부터 n까지의 번호가 붙은 방을 지나가야 하는 마법의 미로
- 각 방 안에는 번호가 붙은 문이 있을 수 있고, 각 문은 해당하는 번호의 방으로 통한다. 방 안에는 레프리콘이나 트롤이 있을 수도 있다.
- 레프리콘이 있는 방에 들어가면 레프리콘은 모험가의 소지금이 일정 양 이하로 떨어지지 않게 채워준다. 레프리콘은 모험가의 소지금이 일정량 미만일 때에는 그만한 양이 되도록 금화를 채워주고, 소지금이 일정량 이상일 때에는 그대로 둔다. 트롤이 있는 방에 들어가려면 일정량의 통행료를 지불해야 한다. 이는 맨 처음에 모험가가 1번 방에서 시작하려 할 때에도 마찬가지이다.
- 모험가는 소지금이 0인 상태에서 출발한다. 과연 모험가는 1번 방에서 출발해서 n번 방에 도착할 수 있을까?
- 
- 생각 흐름
	- 피보나치와 비슷하다고 생각
	- 두 노드 사이의 거리가 무조건 최소 길이 
	- 갈 수 있는 경우를 타고 타고 목적지로 가면 끝 -> 방문 체크 하면 끝 

	

``` c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int n;

struct room{
	char type;
	int price = 0;
	vector<int> go;
};

bool check(room &A, int &user){
	if(A.type == 'E') return true;
	if(A.type == 'L'){
		if(A.price > user){
			user = A.price;
		}
		return true;
	}
	if(A.type == 'T'){
		if(A.price > user) return false;
		else{
			user -= A.price;
			return true;
		}
	}
	return false;
}

bool func(vector<room> &node, int &user){
	// 큐를 활용해서 목적지까지 도달 가능 여부 경로 저장 
	// 처음 방문할 위치 저장 
	queue<int> q;
	q.push(1);

	vector<bool> flag(n+1,false);
	
	while(!q.empty()){
		int idx = q.front();
		q.pop();

		// 이동 가능 
		if(!flag[idx] && check(node[idx],user)){
			flag[idx] = true;
			// n번 노드 방문 가능
			if(idx == n){
				return true;
			}
			for(int i=0; i < node[idx].go.size(); i++){
				q.push(node[idx].go[i]);
			}
		}
	}
	
	return false;
}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    while(1){
    	cin >> n;
    	if(n == 0) break;
    	int user = 0;
		// 1~n 
		vector<room> node(n+1);
		for (int i = 1; i <= n; i++) {
			room tmp;
			cin >> tmp.type >> tmp.price;
			while(1){
				int num;
				cin >> num;
				if(num == 0) break;
				tmp.go.push_back(num);
			}
			node[i] = tmp;
		}

		// 시작 위치에서 불가능한 경우 
		if(!check(node[1], user)){
			cout << "No" << "\n";
		}else{
			if(func(node, user)){
				cout << "Yes" << "\n";
			}else{
				cout << "No" << "\n";
			}
		}
    }
	
	return 0;
}

```
