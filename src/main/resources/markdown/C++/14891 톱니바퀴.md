---
createdAt: 2025-08-02T18:52:14.0359882
modifiedAt: 2025-08-02T18:52:14.0359882
---
- 총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이 일렬로 놓여져 있다. 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, 그 오른쪽은 3번, 가장 오른쪽 톱니바퀴는 4번이다.
-  톱니바퀴를 총 K번 회전,  톱니바퀴를 총 K번 회전, 회전은 시계 방향과 반시계 방향이 있다.
-  톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면, B는 A가 회전한 방향과 반대방향으로 회전하게 된다.
- 톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때, 최종 톱니바퀴의 상태를 구하는 프로그램을 작성

- 입력: 첫째 줄에 1번 톱니바퀴의 상태, 둘째 줄에 2번 톱니바퀴의 상태, 셋째 줄에 3번 톱니바퀴의 상태, 넷째 줄에 4번 톱니바퀴의 상태가 주어진다. 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다. N극은 0, S극은 1로 나타나있다. 다섯째 줄에는 회전 횟수 K(1 ≤ K ≤ 100)가 주어진다. 다음 K개 줄에는 회전시킨 방법이 순서대로 주어진다. 각 방법은 두 개의 정수로 이루어져 있고, 첫 번째 정수는 회전시킨 톱니바퀴의 번호, 두 번째 정수는 방향이다. 방향이 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향이다.

- 출력: 총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합을 출력

- 생각 흐름
	- 톱니바퀴들의 맞다은 톱니의 상태 확인 후에 회전  
	- 톱니 회전 후의 상태 관리를 위해 deque 이용해서 시계, 반시계 관리 
	- + deque의 swap 이용해서 갱신 예정 + deque는 = 으로 딥카피 가능 
	- 회전되는 톱니 기준  왼쪽, 오른쪽 위치가 영향 
- 시간 잡아먹었던 것 
	- 입력값 10010001 이게 string 으로 받았어야 함 

``` c++
#include <iostream>
#include <deque>
#include <cmath>
using namespace std;

int k;

// dir = 0 -> 회전 x, 1 -> 시계, 2 -> 반시계
struct sawTooth{
	deque<int> pos;
};

// 시계 -> 반시계, 반시계 -> 시계 방향을 리턴
int sawDir(int dir) {
	if(dir == 1) return -1;
	if(dir == -1) return 1;
}

// dir에 따른 시계, 반시계 이동시키는 함수
void move(int dir, int idx, sawTooth (&arr)[5]) {
	if(dir == 1){
		int last = arr[idx].pos.back();
		arr[idx].pos.pop_back();
		arr[idx].pos.push_front(last);
	}else {
		int front = arr[idx].pos.front();
		arr[idx].pos.pop_front();
		arr[idx].pos.push_back(front);
	}
}

// 회전 명령에 따른 나머지 톱니들의 움직임 
void slide(int idx, int dir, sawTooth (&arr)[5]) {
	int leftTmp = idx;
	int rightTmp = idx;

	// idx 기준 왼쪽 방향 연산
	// for문 이후의 tmp값까지 move 돌리면 됨
	for(int i = idx - 1; i>=1; i--){
		if(arr[leftTmp].pos[6] != arr[i].pos[2]){
			leftTmp = i; 
		}else{
			break;
		}
	}

	// idx 기준 오른쪽 방향 연산
	for(int i = idx + 1; i <=4; i++){
		if(arr[rightTmp].pos[2] != arr[i].pos[6]){
			rightTmp = i;
		}else{
			break;
		}
	}

	// 톱니바퀴 회전 수행 
	move(dir, idx, arr);
	int newDir = sawDir(dir);
	for(int i=idx-1; i >= leftTmp; i--) {
		move(newDir, i, arr);
		newDir = sawDir(newDir);
	}
	newDir = sawDir(dir);
	for(int i=idx+1; i <= rightTmp; i++) {
		move(newDir, i, arr);
		newDir = sawDir(newDir);
	}
}

// 점수의 합을 리턴하는 함수
int getPoint(sawTooth (&arr)[5]) {
	int sum = 0;
	for(int i=1; i<=4; i++){
		if(arr[i].pos[0] == 1){
			sum += pow(2,(i-1));
		}
	}
	return sum;
}

int main() {
	sawTooth arr[5];
	
	for (int i = 1; i <= 4; i++) {
		string tmp;
		cin >> tmp;
		for (int j = 0; j < 8; j++) {
			arr[i].pos.push_back(tmp[j] - '0');
		}
	}
		
	cin >> k;
	
	for (int i = 0; i < k; i++) {
		int idx, dir;
		cin >> idx >> dir;
		slide(idx, dir, arr);
	}

	int res = getPoint(arr);
	cout << res;
	return 0;
}

```
