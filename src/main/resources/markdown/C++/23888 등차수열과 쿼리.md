---
createdAt: 2025-08-02T18:52:14.8467633
modifiedAt: 2025-08-02T18:52:14.8467633
---
- 첫째 줄에 수열의 초항 a와 공차 d가 주어진다.
- 둘째 줄에는 쿼리의 개수 q가 주어진다.
- 셋째 줄부터 q개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.
- 쿼리: 1 L R -> L ~ R까지 합,  2 L R -> L~R 까지의 최대 공약수 

- 생각 흐름
	- a,d,r,q 모두 10^6 이면 -> O(N^2) 이면 시간 초과 
		- 합의 경우에는 l-r의 차이 +1, x 만큼 a * x + d * (x-1) -> O(N) 가능  
		- 최소 공약수를 구하는 경우 
			- 만약 최소 공약수 1부터 L 까지 -> O(N^2) -> 시간초과 
			- 백만까지의 서로소를 모두 계산하는건 무리
			- 최소 공약수가 x 라면 -> x로 나눈 몫도 등차 ->  이 등차는 d / x
			- a와 d의 최대 공약수가 최대 공약수 -> O(Nlog)

	

``` c++
#include <iostream>
#include <vector>
using namespace std;

long long a, d, q;

long long remain(long long x, long long y){
	if( x < y ){
		long long tmp = x;
		x = y;
		y = tmp; 
	}
	if(y == 0 ) return x;
	return remain(y, x%y);
}

void calc(int method, long long l, long long r) {	
	if(method == 1){
		// ex) 1 4 8 -> sum of a+3d ~ a+7d  
		// ex) 1 x y -> a+(x-1)d + a+(x)d + a(x+1)d ... +a(y-1)d
		// -> a * (y-x+1) + (y-1)*y/2 - (x-1)*x/2 
		// 등차수열의 합: n{2a+(n-1)d}/2
		long long ans = ((r*(2*a + (r-1)*d)) - ((l-1)*(2*a + (l-2)*d)))/2;
		cout << ans << "\n";
		return;
	}else{

		if(l == r){
			cout << a + (l-1)*d << "\n";
			return;
		}
		// ex) 2 4 8 -> min divisor of a+3d ~ a+7d
		// 최소 공약수가 x 
		// 4 6 8 10 12-> 2*2 , 2*3 , 2*2*2 ,2*5, 2*3*2
		// 4 10 16 22 ->  2 5 8 11  -> d:6, x:2 -> 몫들의 등차는 d/x 3
		// 5 10 15 20 -> 1 2 3 4 -> d:5, x:5 -> 등차 1
		// 15 17 19 21 -> d:2, x:1
		// |4| 8 12 16 -> d:4, x:4 -> 등차 1 
 		// -> 기존 등차의 약수중에 공약수 존재: 초항과 공차의 최대 공약수 
		// a와 d의 최대 공약수가 l~r까지의 최대 공약수
		cout << remain(a, d) << "\n";
	}

}

int main() {
	cin >> a >> d >> q;
	for (int i = 0; i < q; i++) {
		int method;
		long long l,r;
		cin >> method >> l >> r;
		calc(method, l, r);
	}
	
	return 0;
}

```
