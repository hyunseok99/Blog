---
createdAt: 2025-08-02T18:52:15.0609433
modifiedAt: 2025-08-02T18:52:15.0609433
---
- 오늘 결승전에 뛸 선발 선수 11명은 미리 골라두었지만, 어떤 선수를 어느 포지션에 배치해야 할지 아직 결정하지 못했다.
- 11명의 선수가 각각의 포지션에서의 능력을 0부터 100까지의 정수로 수치화 했다. 0은 그 선수가 그 포지션에 적합하지 않다는 뜻이다.
- 모든 선수의 포지션을 정하는 프로그램을 작성하시오. 모든 포지션에 선수를 배치해야 하고, 각 선수는 능력치가 0인 포지션에 배치될 수 없다.
- 생각 흐름
	- 조합을 이용하여 각각의 포지션에 선택될 선수를 정해서 구현
	- 능력치 합의 최대값이 필요하기에 모든 경우 11! -> 4000만 정도 
	- 능력치가 0이 되는 경우는 폐기
- 처음에 4000만 정도라 시간초과 안날줄 알았는데 초과남
	- -> 11!의 연산을 내부적으로 11번 돌다보니 4억번의 연산 일어나니 시간초과
	- 백트래킹으로 구현 방향성 수정 
	

``` c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n;
int res = -1;

// 조합 구현 및 점수 계산
void func(vector<vector<int>> &player) {
	vector<int> comb = {0,1,2,3,4,5,6,7,8,9,10};
	do{
		int total = 0;
		int idx = 0;
		bool flag = true;
		for(int i=0; i<11; i++, idx++){
			if(player[comb[i]][idx] == 0){
				flag = false;
				break;
			};
			total += player[comb[i]][idx];
		}
		if(flag){
			res = max(res, total);
		}
	}while(next_permutation(comb.begin(),comb.end()));
	cout << res << "\n";
	return;
}

void backTracking(vector<vector<int>> &player, vector<bool> & flag, int lev, int sum){
	if(lev == 11){
		res = max(res, sum);
		return;
	}

	for(int i=0; i<11; i++){
		if(player[i][lev] != 0 && !flag[lev]){
			flag[lev] = true;
			backtracking(player,flag, lev+1, sum + player[i][lev]);
			flag[lev] = false;
		}
	}
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	cin >> n;
	
	vector<vector<int>> player(11, vector<int>(11));
	vector<bool> flag(11,false);
	for (int i = 0; i < n; i++) {
		for(int j=0; j<11; j++){
			for(int k=0; k<11; k++){
				cin >> player[j][k];
			}
		}
		backTracking(player, flag, 0, 0);
	}
	
	return 0;
}

```
