---
createdAt: 2025-08-02T18:52:15.0276731
modifiedAt: 2025-08-02T18:52:39.085948
---
- 3+1 하노이 탑 게임은 가로 방향으로 일렬로 놓인 4개의 기둥과 크기가 서로 다른 $N$개의 원판을 이용한 게임이다. 편의상 왼쪽에 있는 기둥부터 차례대로 A, B, C, D라고 하자.
- 처음에는 기둥 A에 크기가 가장 큰 원판이 아래에 오도록 모든 원판이 크기 순서대로 쌓여 있다. 이 게임의 목표는 아래 규칙을 지키면서 모든 원판을 기둥 D로 옮기는 것이다.
	- 한 번에 1개의 원판만 옮길 수 있다.
	- 어떤 기둥의 맨 위에 있는 원판만 옮길 수 있다.
	- 작은 원판 위에 큰 원판을 놓을 수 없다.
	- 기둥 D에 있는 원판을 다른 기둥으로 옮길 수 없다.**
	- 기둥 A, B, C에 있는 원판은 위 조건을 어기지 않는 한 자유롭게 옮길 수 있다.
- 기둥 A에 있는 $N$개의 원판을 모두 기둥 D으로 옮기기 위해 필요한 최소 이동 횟수를 구하고, 그러한 이동 방법을 아무거나 하나 출력 (  1 <= N <= 20)
- 
- 생각 흐름
	- 기둥 D에 놓는 순간 고정이므로 D에는 무조건 N개의 원판이 크기순으로 와야함 
	- 이동이 많이 일어나기에 O(1)인 stack 또는 queue 이용 
	- 경우의 수 생각:
		1. A의 n번 원판을 -> D로 이동 시키려면 :  n-1개의 원판이 오직 B,C만 이용해서 이동되어 있어야 함
		2. 이후 남은 n-1개의 원판중 n-1번 원판이 B 또는 C에 존재하면 n-1을 제외한 n-2개를 이동 시켜서 n-1번원판을 -> D로 이동 이걸 1번 원판까지 반복 
	- ex )
		-  n = 1인 경우: A -> D
		- n = 2인 경우: A -> B, A -> D, B ->D
		- n = 3인 경우:  A -> B,  A -> C ,  A ->D, C -> D,  B -> D
		- n =4  :  AB, AC, BC, AB, AD, BD, CB, CD, BD
	- n번째가 A에 존재하고 n-1번째가 B에 존재하고 나머지 n-2개가 C에 존재하는 경우의 반복이
	  최소 이동일 것 같음
		-  n >= 3 에서 n, n-1, (1~n-2)가 각각 A,B,C에 존재 할 때 -> 최소 이동으로 D에 n,n-1 안착  
		- n =3 에서 3,2,1 -> 3 = A, 2 = B, 1 = C 면 최소
			- A에 n번, B에 n-1번 C에 나머지 n-2개
		1. n-2개의 원판을 A->C에, n-1번 원판을 B에 
		2. n번 원판을 A -> D, n-1번 원판을 B -> D
		3. n-4개의 원판을 C ->A에, n-3번 원판을 B에
		4. n-2번 원판은 그대로  C -> D, n-3번 원판을 B->D

``` c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int n;

/*
	1. n-2개의 원판을 A->C에, n-1번 원판을 B에
	2. n번 원판을 A -> D, n-1번 원판을 B -> D
	3. n-4개의 원판을 C->A에, n-3번 원판을 B에
	4. n-2번 원판은 그대로  C -> D, n-3번 원판을 B->D
	이럼 최소 이동일듯
*/


// 정답 출력용 이동 경로 
queue<pair<char, char>> res;

char change(char c) {
	if (c == 'A') return 'C';
	return 'A';
}

// 일반적인 경로 저장
void saveMove(int start, int end) {
	res.push({ start, end });
	return;
}

// D로 이동하는 경로 저장
void endMove(int start) {
	// n-1번을 start 에서 -> B로 옮기고 
	// n번을 start에서 -> D로 옮기고
	// n-1번을 B에서 -> D로
	res.push({ start,'B' });
	res.push({ start,'D' });
	res.push({ 'B','D' });
	
	return;
}


// 기존 하노이 3개 짜리 이용해서 n-2개를 A에서 C로 옮기는 작업을 수행하고 이 작업이 끝나면 n-1번, n번을 D로 옮기는 과정을 수행하면 될듯 
// recursion은 A, B , C만 이용 
// 재귀로 A -> C 이동이 끝나면 n, n-1 이동 저장 
// 이 경우는 전역으로 입력 받은 n이 3이상일 떄 최소 1개는 C로 보내야 할 때 필요 마지막 C로 보낸 1개는 다시 D로 보내줘야 함 
void recursion(int n, char start, char end, char use) {
	if (n < 1) return;
	if (n == 1) {
		saveMove(start, end);
	} else {
		// A -> C , A -> B , B -> C 이런식으로 A의 n-2개를 C로 이동 
		recursion(n - 1, start, use, end);
		// A -> C로 이동할 떄의 동선 저장
		saveMove(start,end);
		recursion(n - 1, use, end, start);
	}
}



int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	
	cin >> n;

	if (n < 3) {
		if (n == 1) {
			saveMove('A', 'D');
		}
		else {
			endMove('A');
		}

	}
	else {
		int idx = n - 2;
		// 처음에 n-2 개를 A -> C로 보냈으면 다음에는 C -> A로 보내야 함 
		char firstStart = 'A';
		char firstEnd = 'C';
		while (idx >= 0) {
			// 짝수일 때는 문제가 없는데 홀수면 한개가 남아있음 -> 이거 따로 처리 필요함
			// n-2개를 A -> C로 이동 후에 n, n-1번 D로 이동
			recursion(idx, firstStart, firstEnd, 'B');
			endMove(firstStart);
			firstStart = change(firstStart);
			firstEnd = change(firstEnd);
			// 마지막 1개만 남은경우
			if (idx == 1) {
				// 홀수개인 경우
				if (n % 2 != 0) {
					saveMove(firstStart, 'D');
				}
				else {
					endMove(firstStart);
				}
			}
			idx = idx - 2;
		}
		// 만약 idx = 1 이면 

	}


	cout << res.size() << "\n";
	while (!res.empty()) {
		pair<char, char>move = res.front();
		res.pop();
		cout << move.first << " " << move.second << "\n";
	}

	return 0;
}


```
