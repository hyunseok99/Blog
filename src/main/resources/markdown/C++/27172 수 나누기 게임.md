---
createdAt: 2025-08-02T18:52:15.0028992
modifiedAt: 2025-08-02T18:52:39.0611154
---
- 게임을 시작하기 전 각 플레이어는 1$1$부터 1000000$1\,000\,000$ 사이의 수가 적힌 서로 다른 카드를 잘 섞은 뒤 한 장씩 나눠 가집니다.
- 매 턴마다 플레이어는 다른 플레이어와 한 번씩 결투를 합니다.
- 결투는 서로의 카드를 보여주는 방식으로 진행되며, 플레이어의 카드에 적힌 수로 다른 플레이어의 카드에 적힌 수를 나눴을 때, 나머지가 0$0$이면 승리합니다. 플레이어의 카드에 적힌 수가 다른 플레이어의 카드에 적힌 수로 나누어 떨어지면 패배합니다. 둘 다 아니라면 무승부입니다.
- 승리한 플레이어는 1$1$점을 획득하고, 패배한 플레이어는 1$1$점을 잃습니다. 무승부인 경우 점수의 변화가 없습니다.
- 본인을 제외한 다른 모든 플레이어와 정확히 한 번씩 결투를 하고 나면 게임이 종료됩니다.

- 《수 나누기 게임》의 결과를 가지고 한별이와 내기를 하던 은하는 게임이 종료되기 전에 
  모든 플레이어의 점수를 미리 알 수 있을지 궁금해졌습니다. 은하를 위해 각 플레이어가 가지고 있는 
  카드에 적힌 수가 주어졌을 때, 게임이 종료된 후의 모든 플레이어의 점수를 구해주세요.

- 생각 흐름
	- 모든 사람과 게임을 하는 경우와 전체 경우가 동일함. (n-1)!의 연산 -> 시간 복잡도 고려 필요
	- 입력 받은 수가 소수인 경우 ->1이 아닌 소수들과 모두 무승부 
	- 아닌 경우 -> 약수의 갯수 이용해서 점수 계산 
	- 소수인지 판단하는게 핵심 -> 에라토스의 체 이용하면 nlogn으로 시간복잡도 줄어든다 
	- 1~1000001 -> 1~1000 까지의 소수 

``` c++
#include <iostream>
using namespace std;

int n;
int res[1000001];
bool check[1000001];
vector<int> card;


int main() {
	cin >> n;
	
	for(int i=0; i < n; i++) {
		int tmp;
		cin >> tmp;
		card.push_back(tmp);
		check[tmp] = true;
	}

	for(int i = 0; i < n; i++){
		// 해다 카드의 배수 탐색 및 점수 계산
			for(int j = card[i] * 2; j < 1000001; j += card[i]){
				if(check[j]){
					res[card[i]]++;
					res[j]--;
				}
			}

	}
	
	for(int i = 0; i < n; i++){
		cout << res[card[i]] << " ";
	}
	
	return 0;
}

```
