---
createdAt: 2025-08-02T18:52:14.1975797
modifiedAt: 2025-08-02T18:52:38.356528
---
- 정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다.
-  만약, 그동안 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해
-  입력: 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.
- 
- 생각 흐름
	- 시간제한이 0.1초 -> 천만번 연산정도 
	- 우선순위큐
		- push,pop -> logN
	- 2개의 우선순위 큐를 이용해서 
		- 1번 큐 값, 2번 큐 값, 넣을 값을 이용해서 구현하면 될 듯
		- 1번 큐는 큰값 pop, 2번 큐는 작은 값 pop

	- 1,3 : 5 -> 1,3 : 4, 5 -> 1, 2, 3 : 4,5
		-  넣을 수가 왼쪽 가장 큰 값보다 큰 경우  -> 2번째 push , 아닌 경우 왼쪽 
		-  양쪽 갯수 밸런스 
	- 1 7   -> 1 5 -> 1 2 -> 1 2 6 -> 1 2 5
	- 5     ->  7 2 -> 5 7 -> 5 7 -> 6 7
``` c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int n;

priority_queue<int> q1;
priority_queue<int, vector<int>, greater<int>> q2;


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	cin >> n;

	int leftTop = -1;
	int rightTop = -1;

	// i번째 삽입
	for(int i=1; i<=n; i++){
		int m;
		cin >> m;

		if( i % 2 == 1){
			q1.push(m);
		}else{
			q2.push(m);
		}

		if(i >= 2){
			leftTop = q1.top();
			rightTop = q2.top();
			if(leftTop > rightTop){
				q1.pop();
				q2.pop();
				q1.push(rightTop);
				q2.push(leftTop);
			}
		}

		cout << q1.top() << "\n";
	}
	
	return 0;
}

```
