---
createdAt: 2025-08-02T18:52:14.3026311
modifiedAt: 2025-08-02T18:52:14.3026311
---
- 크기가 3×3인 배열 A가 있다. 배열의 인덱스는 1부터 시작한다. 1초가 지날때마다 배열에 연산이 적용된다.
- R 연산: 배열 A의 모든 행에 대해서 정렬을 수행한다. 행의 개수 ≥ 열의 개수인 경우에 적용된다.
- C 연산: 배열 A의 모든 열에 대해서 정렬을 수행한다. 행의 개수 < 열의 개수인 경우에 적용된다.
- 한 행 또는 열에 있는 수를 정렬하려면, 각각의 수가 몇 번 나왔는지 알아야 한다. 그 다음, 수의 등장 횟수가 커지는 순으로, 그러한 것이 여러가지면 수가 커지는 순으로 정렬한다. 그 다음에는 배열 A에 정렬된 결과를 다시 넣어야 한다. 정렬된 결과를 배열에 넣을 때는, 수와 등장 횟수를 모두 넣으며, 순서는 수가 먼저이다.
- 정렬된 결과를 배열에 다시 넣으면 행 또는 열의 크기가 달라질 수 있다. R 연산이 적용된 경우에는 가장 큰 행을 기준으로 모든 행의 크기가 변하고, C 연산이 적용된 경우에는 가장 큰 열을 기준으로 모든 열의 크기가 변한다. 행 또는 열의 크기가 커진 곳에는 0이 채워진다. 수를 정렬할 때 0은 무시해야 한다. 예를 들어, [3, 2, 0, 0]을 정렬한 결과는 [3, 2]를 정렬한 결과와 같다.
- 행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버린다.
- 배열 A와 r, c, k가 주어졌을 때, r,c 배열에 들어있는 값이 k가 되기 위한 최소 시간을 구하시오 
- 입력: 
	- 첫째 줄에 r, c, k가 주어진다. (1 ≤ r, c, k ≤ 100)
	- 둘째 줄부터 3개의 줄에 배열 A에 들어있는 수가 주어진다. 배열 A에 들어있는 수는 100보다 작거나 같은 자연수이다.
	- 시간 제한 0.5초
- 생각 흐름
	- row 크기와, col 크기를 계속 가지고 있어야 함 
		- 100 * 300 * 100 = 삼백만 <= 0.5초 
- 주의
	- 기존의 갯수보다 줄어드는 경우를 고려해줘야 한다. 
	

``` c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

int r, c, k;

bool cmp(pair<int, int> a, pair<int, int> b) {
	if (a.second != b.second) {
		return a.second < b.second;
	}
	else {
			return a.first < b.first;
	}
}


bool check(vector<vector<int>>& arr) {
	if (arr[r][c] == k) {
		return true;
	}
	return false;
}

void calcRow(vector<vector<int>>& arr, int& row, int& col) { // R연산 row >= col
	if (col >= 100) return;
	int curCol = col;
	// col 갱신 
	for (int i = 1; i <= row; i++) {
		vector<int> cnt(101);
		vector<pair<int, int>> v;
		for (int j = 1; j <= col; j++) {
			cnt[arr[i][j]]++;
		}
		for (int j = 1; j <= 100; j++) {
			if (cnt[j] != 0) {
				v.push_back({ j, cnt[j] });
			}
		}
		sort(v.begin(), v.end(), cmp);
		int idx = 1;
		for (int j = 0; j < v.size(); j++) {
			pair<int, int> tmp = v[j];
			if (idx <= 100) {
				arr[i][idx++] = tmp.first;
				arr[i][idx++] = tmp.second;
			}
		}
		while (idx <= col) {
			arr[i][idx++] = 0;
		}
		curCol = max(curCol, (int)(2 * v.size()));
	}
	col = curCol;
	if (col > 100) col = 100;
}

void calcCol(vector<vector<int>>& arr, int& row, int& col) { // C연산 row < col
	if (row >= 100) return;
	int curRow = row;
	for (int j = 1; j <= col; j++) {
		vector<int> cnt(101);
		vector<pair<int, int>> v;
		for (int i = 1; i <= row; i++) {
			cnt[arr[i][j]]++;
		}
		for (int i = 1; i <= 100; i++) {
			if (cnt[i] != 0) {
				v.push_back({ i, cnt[i] });
			}
		}
		sort(v.begin(), v.end(), cmp);
		int idx = 1;
		for (int i = 0; i < v.size(); i++) {
			pair<int, int> tmp = v[i];
			if (idx <= 100) {
				arr[idx++][j] = tmp.first;
				arr[idx++][j] = tmp.second;
			}
		}
		while(idx <= row){
			arr[idx++][j] = 0;
		}
		curRow = max(curRow, (int)(2 * v.size()));
	}
	row = curRow;
	if (row > 100) row = 100;
}

// time에 따른 R,C 연산 
void calc(vector<vector<int>>& arr, int& row, int& col) {
	if (row >= col) {
		calcRow(arr, row, col);
	}
	else {
		calcCol(arr, row, col);
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	cin >> r >> c >> k;
	vector<vector<int>> arr(101, vector<int>(101));
	int col = 3;
	int row = 3;

	for (int i = 1; i <= 3; i++) {
		for (int j = 1; j <= 3; j++) {
			cin >> arr[i][j];
		}
	}
	int time = 0;
	while (time <= 100) {
		if (time == 52) {
			int s = 52;

		}
		if (check(arr)) {
			break;
		}
		calc(arr, row, col);
		time++;
	}
	if (time > 100) {
		cout << -1;
	}
	else {
		cout << time;
	}
	return 0;
}

```
