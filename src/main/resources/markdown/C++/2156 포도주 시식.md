---
createdAt: 2025-08-02T18:52:14.6948246
modifiedAt: 2025-08-02T18:52:14.6948246
---
-  DP 유형 문제 숙련도 쌓으려고 풂 
- 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 
  각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 
  가장 많은 양의 포도주를 마시도록 구현 
	1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
	2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
- 생각 흐름
	- 마시는 조합들이 핵심 
	- 1잔을 먹는 경우 부터 시작해서 n잔을 먹는 경우까지 구하고 만약 연속된 3개의 잔이 있는 경우를 제외하는 식으로 먼저 구현해보려고 생각 -> n^2 이라 불가능
	- 가장 많은 잔을 먹는 것보다 더 적은 수의 잔을 먹는데 포도주의 양은 더 큰 경우도 있다고 가정 
		- x번째 포도주를 먹을 때 결국 1,2번 전에 먹은 잔만 고려하면 된다. 이걸 인자로 받아서 구현 하면 될 듯 -> n으로 가능할 듯 
	- 가능한 경우
		- x번째 잔 안먹는 경우
		- x번째 잔 먹는 경우

``` c++
#include <iostream>
using namespace std;

// grape: n번째 포도주잔에 들어있는 포도주의 양 

int n;
int grape[10001];
int res[10001];

int main() {
	cin >> n;

	// 1잔을 마시는 경우 초기화 
	for(int i = 1; i <= n; i++){
		int t;
		cin>>t;
		grape[i] = t;
	}

	// x잔 존재할 때 최대값 계산
	res[1] = grape[1]; // x=1
	if(n >= 2) { // x=2
		res[2] = grape[1] + grape[2];
	}
	
	if( n >= 3) { // n=3
		res[3] = max(max(res[2], (grape[1] + grape[3]), (grape[2] + grape[3])));
	}

	// 일반적인 경우의 최대값 계산
	// i번째를 먹지 않는 경우와 먹는 경우 (먹는 경우에는 이전 안먹는 경우 or 연속으로 2잔)
	for(int i = 4; i <= n; i++){	
		res[i] = max(res[i-1], max(grape[i]+res[i-2]
					, grape[i]+grape[i-1]+res[i-3]));
	}
	
	cout << res[n];
	
	return 0;
}

```
