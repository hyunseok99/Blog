---
createdAt: 2025-08-02T18:52:14.9527274
modifiedAt: 2025-08-02T18:52:39.01887
---
- 화살표는 각 지점을 잇는 도로를 의미하며 모든 도로는 일방통행 도로로 화살표 방향으로만 움직일 수 있다.
- 자동차 경주의 코스는 1번 지점에서 출발하여 다시 1번 지점으로 되돌아오는 것이다. 단, 중간에는 1번 지점을 지나서는 안 된다. 경주로는 1번 지점을 제외한 어느 지점에서 출발하여도 1번 지점을 지나가지 않고서는 같은 지점으로 돌아올 수 없도록 되어 있다.
- 또한 1번 지점에서 다른 모든 지점으로 갈 수 있고, 다른 모든 지점에서 1번 지점으로 갈 수 있다.
- 각 도로에는 그 도로를 지날 때 얻는 점수가 있다.
- 1번 지점에서 출발하여 가장 많은 점수를 얻어 다시 1번 지점으로 돌아오는 팀이 우승을 하게 된다. 가장 많은 점수를 얻어 1번 지점으로 돌아오는 경로를 찾아 그 얻는 점수와 경로를 출력하는 프로그램을 작성하시오.
- 각 지점 N은 1000이하의 자연수 

- 생각 흐름
	- 다시 1번 지점을 도달 하는 순간 끝 
	- 사이클의 형태이기에 특정 지점 이동까지의 최대 값은 정해져 있음  
	- N = 1인 경우 주의 
- 복기
	- 위상 정렬 이용 -> O(V +E) : 정점과 간선의 수에 따른 시간 복잡도 
	- 노드를 순서대로 처리하여 각 노드의 최장거리를 갱신해 나가야 함 
	- res[i] -> 1번 노드에서 i번 노드까지 도달하는 경로 최대 점수 
	- prevRes[i]-> i번 노드에서 최대 점수 도달 직전의 노드 -> 경로 복원용

	

``` c++
#include <iostream>
#include <vector>
using namespace std;

int n;
int score;
vector<int> resPath;

// path: 경로 
void func(int spot, int sum, vector<vector<int>> node, vector<int> path, vector<bool> flag){
	// 방문 체크 
	flag[spot] = true;

	// 원점 도착
	if(spot == 1){
		if(score < sum){
			score = sum;
			resPath = path;
		}
		return;
	}
	
	for(int i=1; i<=n; i++){
		if(!flag[i]){
			if(node[spot][i] != 0){
				sum += node[spot][i];
				path.push_back(i);
				func(i, sum, node, path, flag);
			}
		} 
		
	}
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	cin >> n;
	vector<vector<int>> node(n+1, vector<int>(n+1));
	vector<bool> flag(n+1, false); 
	
	for (int i = 1; i <= n; i++) {
		int p,q,r;
		cin >> p >> q >> r;
		node[p][q] = r;
	}

	// 처음에 1로 부터 갈 수 있는 곳 연산 
	for(int i = 1; i<=n; i++){
		resPath.push_back(1);
		if(node[1][i] != 0){
			resPath.push_back(i);
			func(i, node[1][i], node, path, flag);
		}
	}

	cout << score << "\n";
	for(int i=0; i<res.size(); i++){
		cout << res[i] << " ";
	}
	return 0;
}

```
