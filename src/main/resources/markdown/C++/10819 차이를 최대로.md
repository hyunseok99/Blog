---
createdAt: 2025-08-02T18:52:13.7709208
modifiedAt: 2025-08-02T18:52:13.7709208
---
- 백트래킹 연습
- N개의 정수로 이루어진 배열 A가 주어진다. 이때, 배열에 들어있는 정수의 순서를 적절히 바꿔서 다음 식의 최댓값을 구하는 프로그램을 작성하시오.
- |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]|
- 첫째 줄에 N (3 ≤ N ≤ 8)이 주어진다. 둘째 줄에는 배열 A에 들어있는 정수가 주어진다. 배열에 들어있는 정수는 -100보다 크거나 같고, 100보다 작거나 같다.

- 생각 흐름
	- 모든 경우에 대해서 연산하기 보다는 특정 지점까지의 계산 결과 유지하고 그 이후의 순서 변화에 맞게 연산이 효율적
	
- next_permutation 쓸 때 -> 사전순 기반 작동이므로 정렬 후에 사용

``` c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int n, res=-1;
vector<int> arr;

void calc() {
	int total = 0;
	for(int i=0; i<=n-2; i++){
		int j = i+1;
		int val = abs(arr[i] - arr[j]);
		total += val;
	}
	res = max(total, res);
}

void backTracking() {
	do{
		calc();
	}while(next_permutation(arr.begin(),arr.begin()+n));
}

int main() {
	cin >> n;
	for (int i = 0; i < n; i++) {
		int tmp;
		cin>>tmp;
		arr.push_back(tmp);
	}
	sort(arr.begin(), arr.end());
	backTracking();
	cout << res;
	
	return 0;
}

```
