---
createdAt: 2025-08-02T18:52:14.2446928
modifiedAt: 2025-08-02T18:52:38.4022146
---
- 새 집의 크기는 N×N의 격자판으로 나타낼 수 있고, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 (r, c)로 나타낼 수 있다.
- 오늘은 집 수리를 위해서 파이프 하나를 옮기려고 한다. 파이프는 2개의 연속된 칸을 차지하는 크기이다.
- 파이프는 회전시킬 수 있으며, 아래와 같이 3가지 방향이 가능
- 파이프를 밀어서 이동시키려고 한다. 벽에는 새로운 벽지를 발랐기 때문에, 파이프가 벽을 긁으면 안 된다. 즉, 파이프는 항상 빈 칸만 차지해야 한다.
	- 파이프를 밀 수 있는 방향은 총 3가지가 있으며, →, ↘, ↓ 방향이다. 파이프는 밀면서 회전시킬 수 있다. 회전은 45도만 회전시킬 수 있으며, 미는 방향은 오른쪽, 아래, 또는 오른쪽 아래 대각선 방향이어야 한다.
- 생각 흐름
		- 가로, 세로, 대각선인 경우에 가능한 경우들을 저장해 놓고 더 이상 수행 못하면 끝 

	

``` c++
#include <iostream>
#include <vector>
using namespace std;

int n, m;
int res;

// 가로 세로 대각
int dx[3] = {0, 1, 1};
int dy[3] = {1, 0, 1};

// type: 헌재 파이프 방향, dir: 이동 방향
bool regulation(int type, int dir, pair<int,int> newEnd, vector<vector<int>> &arr){
	int x = newEnd.first;
	int y = newEnd.second;

	if(type == 1){
		if(dir == 0){
			if(x >=1 && x <= n && y >= 1 && y <= n ){
				if(arr[x][y] == 0){
					return true;
				}
			}
			return false;
		}else if(dir == 2){
			if(x >=1 && x <= n && y >= 1 && y <= n ){
				if(y-1 >=1 && y-1 <= n && arr[x][y-1] == 0){
					return true;
				}
			}
			return false;
		}
	}else if(type == 2){
		if( dir == 1){
			if(x >= 1 && x <= n && y >= 1 && y <= n){
				if(arr[x][y] == 0){
					return true;
				}
			}
			return false;
		}else if(dir == 2){
			if(x >=1 && x <= n && y >= 1 && y <= n ){
				if(y+1 >=1 && y+1 <= n && arr[x][y+1] == 0){
					return true;
				}
			}
			return false;
		}
	}else{ // type == 3 대각인 경우 -> 자동으로 가로, 세로, 대각 검증 
		if(x >=1 && x <= n && y >= 1 && y <= n ){
			if(arr[x][y] == 0){
				return true;
			}
		}
		return false;
	}
	return false;
}
// 재귀 함수
void func(pair<int,int> start, pair<int,int> end, vector<vector<int>> &arr){
	if(end.first == n && end.second == n && arr[end.first][end.second] == 0){
		res++;
		return;
	}

	if(start.second == end.second){ // 가로인 경우
		for(int i=0; i < 3; i++){ // 만약 0번 방향 불가능 하면 2번도 불가 
			if(i==1) continue;
			pair<int,int> newEnd 
			= make_pair(end.first + dx[i], end.second + dy[i]);
			if( regulation(1,i, newEnd, arr)){
				func(make_pair(start.first+dx[i], start.second+dy[i]), newEnd, arr);
			}else{
				i += 3;
			}
		}	
	}else if(start.first == end.first){ // 세로인 경우
		for(int i = 1; i < 3; i++){ // 1번 불가능 하면 2번도 불가
			pair<int,int> newEnd 
			= make_pair(end.first + dx[i], end.second + dy[i]);
			if( regulation(2,i, newEnd, arr)){
				func(make_pair(start.first+dx[i], start.second+dy[i]), newEnd, arr);
			}else{
				i += 3;
			}
		}
	}else{ // 대각인 경우
		bool flag = true; 
		for(int i = 0; i < 3; i++){
			pair<int,int> newEnd 
			= make_pair(end.first + dx[i], end.second + dy[i]);
			if(i == 2 && flag == false){
				continue;
			}
			if( regulation(3,i, newEnd, arr)){
				func(make_pair(start.first+dx[i], start.second+dy[i]), newEnd, arr);
			}else{
				flag = false;
			}
		}
	}

}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    
	cin >> n;
	vector<vector<int>> arr(n+1, vector<int>(n+1));

	for(int i=1; i<=n; i++){
		for(int j=1; j<=n; j++){
			cin >> arr[i][j];		
		}
	}


	func(make_pair(1,1), make_pair(1,2), arr);

	cout << res;
	return 0;
}

```
